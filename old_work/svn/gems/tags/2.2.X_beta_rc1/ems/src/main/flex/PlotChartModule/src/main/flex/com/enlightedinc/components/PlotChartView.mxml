<?xml version="1.0" encoding="utf-8"?>
<mx:VBox xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 width="100%" height="100%"
		 verticalGap="0"
		 creationComplete="onCreationComplete()"
		 xmlns:components="com.enlightedinc.components.*"
		 xmlns:renderers="com.enlightedinc.components.renderers.*">
	
	<fx:Declarations>
		<mx:SolidColor id="sc1" color="0xFBB917" alpha=".3"/>
		<mx:SolidColor id="sc2" color="0xFBB917" alpha=".6"/>
		<mx:SolidColor id="sc3" color="0xFBB917" alpha="1"/>	
		<s:SolidColorStroke id="s2" color="0xFBB917" weight="1"/>
		
		<mx:Fade id="fadeIn" alphaFrom="0.0" alphaTo="0.6" duration="1000"/>
		<mx:Fade id="fadeOut" alphaFrom="0.6" alphaTo="0.0" duration="1000"/>
		
		<mx:WipeLeft id="wipeleft" duration="200"/>
		<mx:WipeRight id="wiperight" duration="200"/>
		
		<mx:DateFormatter id="dateFormatter" formatString="YYYY-MM-DD JJ:NN:SS"/>
		
		<s:HTTPService id="fixtureHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetFixture(event)"
					   fault="onGetFixtureFailure(event)"/>
		
		<s:HTTPService id="gatewayHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetGateway(event)"
					   fault="onGetGatewayFailure(event)"/>
		
		<s:HTTPService id="locatorDeviceHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetLocatorDevice(event)"
					   fault="onGetLocatorDeviceFailure(event)"/>
		
		<s:HTTPService id="switchHttpService" 
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetSwitch(event)"
					   fault="onGetSwitchFailure(event)"/>

		<s:HTTPService id="wdsHttpService" 
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetWds(event)"
					   fault="onGetWdsFailure(event)"/>
		
		<s:HTTPService id="areaHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetArea(event)"
					   fault="onGetAreaFailure(event)"/>
		
		<s:HTTPService id="profileHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetProfile(event)"
					   fault="onGetProfileFailure(event)"/>
		
		<s:HTTPService id="dimFixtureHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"
					   resultFormat="xml"
					   result="dimFixtureResult(event)"
					   fault="dimFixtureFailure(event)"/>
		
		<s:HTTPService id="fixuteModeHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"
					   resultFormat="xml"
					   result="fixtureModeResult(event)"
					   fault="fixtureModeFailure(event)"/>
		
		<s:HTTPService id="realtimeHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"
					   resultFormat="xml"
					   result="realTimeResult(event)"
					   fault="realTimeFailure(event)"/>
		
		<s:HTTPService id="updateFixturePositionHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"
					   resultFormat="xml"
					   result="fixturePositionUpdateResult(event)"
					   fault="fixturePositionUpdateFailure(event)"/>
		
		<s:HTTPService id="updateGatewayPositionHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"
					   resultFormat="xml"
					   result="gatewayPositionUpdateResult(event)"
					   fault="gatewayPositionUpdateFailure(event)"/>
		
		<s:HTTPService id="updateSwitchPositionHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"
					   resultFormat="xml"
					   result="switchPositionUpdateResult(event)"
					   fault="switchPositionUpdateFailure(event)"/>
		
		<s:HTTPService id="updateLocatorDevicePositionHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"
					   resultFormat="xml"
					   result="locatorDevicePositionUpdateResult(event)"
					   fault="locatorDevicePositionUpdateFailure(event)"/>

		<s:HTTPService id="updateWdsPositionHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"
					   resultFormat="xml"
					   result="wdsPositionUpdateResult(event)"
					   fault="wdsPositionUpdateFailure(event)"/>

		<s:HTTPService id="getServerGMTOffsetHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true" 
					   result="getServerGMTOffsetResult(event)"
					   fault="getServerGMTOffsetFailure(event)"/>		
		
		<s:HTTPService id="fixuteRealtimeHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"
					   resultFormat="xml"
					   result="fixtureRealTimeResult(event)"
					   fault="fixtureRealTimeFailure(event)"/>
		
		<s:HTTPService id="getFixtureByIdHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true" 
					   result="getFixtureByIdResult(event)"
					   fault="getFixtureByIdFailure(event)"/>
		
		<s:HTTPService id="gatewayRealtimeHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"
					   resultFormat="xml"
					   result="gatewayRealTimeResult(event)"
					   fault="gatewayRealTimeFailure(event)"/>
		
		<s:HTTPService id="getGatewayByIdHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true" 
					   result="getGatewayByIdResult(event)"
					   fault="getGatewayByIdFailure(event)"/>
		
		<s:HTTPService id="getGatewayDeatilsHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true" 
					   result="getGatewayDetailsResult(event)"
					   fault="getGatewayDetailsFailure(event)"/>
		
		<s:HTTPService id="fixtureOutageHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetFixtureOutageList(event)"
					   fault="onGetFixtureOutageListFailure(event)"/>
		
		<s:HTTPService id="motionGroupsListHttpService"
			   method="GET"
			   resultFormat="e4x"
			   useProxy="false"
			   showBusyCursor="true"   
			   result="onGetMotionGroupsList(event)"
			   fault="onGetMotionGroupsListFailure(event)"/>

		<s:HTTPService id="switchGroupsListHttpService"
			   method="GET"
			   resultFormat="e4x"
			   useProxy="false"
			   showBusyCursor="true"   
			   result="onGetSwitchGroupsList(event)"
			   fault="onGetSwitchGroupsListFailure(event)"/>

		<s:HTTPService id="fixturesByGroupIdHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetFixtuersByGroupId(event)"
					   fault="onGetFixtuersByGroupIdFailure(event)"/>
		
		<s:HTTPService id="getFixturesBySwitchIdHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetFixtuersBySwitchId(event)"
					   fault="onGetFixtuersBySwitchIdFailure(event)"/>

		<s:HTTPService id="getWDSsBySwitchIdHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetWDSsBySwitchId(event)"
					   fault="onGetWDSsBySwitchIdFailure(event)"/>
		
		<s:HTTPService id="updateSwitchFixturesBySwitchIdHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"  
					   resultFormat="xml"
					   result="onUpdateFixtuersBySwitchId(event)"
					   fault="onUpdateFixtuersBySwitchIdFailure(event)"/>

		<s:HTTPService id="updateGroupFixturesByMGIDHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"  
					   resultFormat="xml"
					   result="onUpdateFixtuersByMGId(event)"
					   fault="onUpdateFixtuersByMGIdFailure(event)"/>

		<s:HTTPService id="updateSwitchWDSsBySwitchIdHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true"  
					   resultFormat="xml"
					   result="onUpdateWDSsBySwitchId(event)"
					   fault="onUpdateWDSsBySwitchIdFailure(event)"/>

		<s:HTTPService id="getSceneBySwitchIdHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetSceneBySwitchId(event)"
					   fault="onGetSceneBySwitchIdFailure(event)"/>
		
		<s:HTTPService id="addSceneBySwitchIdHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true" 
					   resultFormat="xml"
					   result="onAddSceneBySwitchId(event)"
					   fault="onAddSceneBySwitchIdFailure(event)"/>
		
		<s:HTTPService id="deleteSceneBySwitchIdHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true" 
					   resultFormat="xml"
					   result="onDeleteSceneBySwitchId(event)"
					   fault="onDeleteSceneBySwitchIdFailure(event)"/>

		<s:HTTPService id="applySceneBySwitchIdHttpService"
					   method="POST"
					   contentType="application/xml"
					   useProxy="false"
					   showBusyCursor="true" 
					   resultFormat="xml"
					   result="onApplySceneBySwitchId(event)"
					   fault="onApplySceneBySwitchIdFailure(event)"/>
		
		<s:HTTPService id="getSceneLevelBySwitchIdHttpService"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetSceneLevelBySwitchId(event)"
					   fault="onGetSceneLevelBySwitchIdFailure(event)"/>
		
		<s:HTTPService id="saveSceneLightLevelBySwitchIdHttpService"
					   method="POST"
					   contentType="application/xml"
					   resultFormat="xml"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onSaveSceneLightLevelBySwitchId(event)"
					   fault="onSaveSceneLightLevelBySwitchIdFailure(event)"/>

		<s:HTTPService id="saveSceneListHttpService"
					   method="POST"
					   contentType="application/xml"
					   resultFormat="xml"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onSaveSceneList(event)"
					   fault="onSaveSceneListFailure(event)"/>
		
		<s:HTTPService id="getImageUpgradeRunningStatus"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetImageUpgradeJobStatus(event)"
					   fault="onGetImageUpgradeJobStatusFailure(event)"/>
		
		<s:HTTPService id="getImageUpgradeDevicesStatus"
					   method="GET"
					   resultFormat="e4x"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onGetImageUpgradeDevicesStatus(event)"
					   fault="onGetImageUpgradeDevicesStatusFailure(event)"/>
		
		<s:HTTPService id="updateSwitchGroupSyncFlag"
					   method="POST"
					   contentType="application/xml"
					   resultFormat="xml"
					   useProxy="false"
					   showBusyCursor="true"   
					   result="onUpdateSwitchGroupSyncFlag(event)"
					   fault="onUpdateSwitchGroupSyncFlagFailure(event)"/>
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import com.enlightedinc.assets.images.Images;
			import com.enlightedinc.components.renderers.DataTipRenderer;
			import com.enlightedinc.components.renderers.FixtureIconRenderer;
			import com.enlightedinc.components.renderers.GatewayIconRenderer;
			import com.enlightedinc.components.renderers.LocatorDeviceItemRenderer;
			import com.enlightedinc.components.renderers.WdsIconRenderer;
			import com.enlightedinc.utils.GlobalUtils;
			
			import mx.charts.events.ChartItemEvent;
			import mx.charts.series.items.PlotSeriesItem;
			import mx.collections.ArrayCollection;
			import mx.collections.Sort;
			import mx.collections.SortField;
			import mx.containers.TitleWindow;
			import mx.controls.Alert;
			import mx.controls.TextInput;
			import mx.core.DragSource;
			import mx.core.FlexGlobals;
			import mx.core.UIComponent;
			import mx.events.CloseEvent;
			import mx.events.CollectionEvent;
			import mx.events.DragEvent;
			import mx.events.FlexEvent;
			import mx.managers.DragManager;
			import mx.managers.PopUpManager;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.rpc.xml.SimpleXMLDecoder;
			
			import org.alivepdf.colors.RGBColor;
			import org.alivepdf.data.Grid;
			import org.alivepdf.data.GridColumn;
			import org.alivepdf.display.Display;
			import org.alivepdf.drawing.Joint;
			import org.alivepdf.fonts.FontFamily;
			import org.alivepdf.fonts.Style;
			import org.alivepdf.images.ImageFormat;
			import org.alivepdf.images.ResizeMode;
			import org.alivepdf.layout.Align;
			import org.alivepdf.layout.Layout;
			import org.alivepdf.layout.Orientation;
			import org.alivepdf.layout.Size;
			import org.alivepdf.layout.Unit;
			import org.alivepdf.pdf.PDF;
			import org.alivepdf.saving.Method;
			
			import spark.components.Label;
			import spark.events.IndexChangeEvent;
			import spark.filters.GlowFilter;
			
			private var TXN_ID:Number = 0;
			[Bindable]
			private var minSliderValue:Number = 100;
			
			private var color:Number = 0x1F29AD;		
			private var glowFilter:GlowFilter = new GlowFilter(color, .8, 6, 6, 5, 1,false, false);
			
			private var xaxis:int = 0;
			private var yaxis:int = 0;
			private var fid:int = 1;
			
			[Bindable]
			private var maxXaxis:int = 0;
			[Bindable]
			private var maxYaxis:int = 0;
			
			private var labelOffsetY:int = 18;
			
			/** 
			 * "gridSize" is a integer value that tells the grid box size and what value x & y axis should be rounded to 
			 **/
			[Bindable]
			private var gridPixels:int = 16;
			
			private var dataTipTimer:Timer;
			private var mouseOverTimer:Timer;
			private var fixtureDetailsTimer:Timer;
			private var gatewayDetailsTimer:Timer;
			private var mouseOverFixture:Object;
			private var mouseOverGateway:Object;
			private var mouseOverSwitch:Object;
			private var mouseOverWds:Object;
			private var mouseOverLocatorDevice:Object;
			private var toolTipColor:String = "0xF8FBA9";
			private var showFullDeatils:Boolean = true;
			private var serverGMTOffset:Number = 0;
			private var autoRefreshTimer:Timer = new Timer(20000);
			private var updateGroupSyncFlagTimer:Timer;
			[Bindable]
			private var selectedItems:Array = new Array;
			
			[Bindable]
			private var fixtureData:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var commissionedFixtureData:ArrayCollection = new ArrayCollection();
			
			[Bindable]
			private var gatewayData:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var commissionedGatewayData:ArrayCollection = new ArrayCollection();
			
			[Bindable]
			private var locatorDeviceData:ArrayCollection = new ArrayCollection();
						
			[Bindable]
			private var switchesData:ArrayCollection = new ArrayCollection();

			[Bindable]
			private var wdsData:ArrayCollection = new ArrayCollection();

			[Bindable]
			private var areaData:ArrayCollection = new ArrayCollection();
			
			private var groupsList:ArrayCollection = new ArrayCollection();
			private var fixturesByGroupList:ArrayCollection = new ArrayCollection();
			
			private var motionGroupsList:ArrayCollection = new ArrayCollection();
			
			private var switchGroupsList:ArrayCollection = new ArrayCollection();
			
			private var fixturesBySwitchList:ArrayCollection = new ArrayCollection();
			private var wdssBySwitchList:ArrayCollection = new ArrayCollection();
			
			private var imageUpgradeFixtureList:ArrayCollection = new ArrayCollection();
			private var imageUpgradeGatewayList:ArrayCollection = new ArrayCollection();
			private var imageUpgradeWdsList:ArrayCollection = new ArrayCollection();
			
			[Bindable]
			private var profileData:ArrayCollection = new ArrayCollection();
			
			[Bindable]
			public var placeHoldersData:ArrayCollection = null;
			private var devicePosition:Point = new Point(0, 0);
			
			private var selectedFixtures:ArrayCollection = new ArrayCollection();
			private var selectedGateways:ArrayCollection = new ArrayCollection();
			private var selectedSwitches:ArrayCollection = new ArrayCollection();
			private var selectedWds:ArrayCollection = new ArrayCollection();
			private var selectedLocatorDevices:ArrayCollection = new ArrayCollection();
			
			private var almostDeadFixtureData:ArrayCollection = new ArrayCollection();
			private var midlifeFixtureData:ArrayCollection = new ArrayCollection();
			private var fullHealthFixtureData:ArrayCollection = new ArrayCollection();
			
			private var almostDeadGlowFilter:GlowFilter = new GlowFilter(0XFF0000, 1, 16, 16, 4, 1,false, false);
			private var midlifeGlowFilter:GlowFilter = new GlowFilter(0XFFA500, 1, 16, 16, 4, 1,false, false);
			private var fullHealthGlowFilter:GlowFilter = new GlowFilter(0X00FF00, 1, 16, 16, 4, 1,false, false);
			
			[Bindable]
			public var searchData:ArrayCollection = new ArrayCollection();
			
			// Holds values of elements before a drag-drop. Used for undo functionality.
			private var localFixtureData:ArrayCollection = new ArrayCollection();
			private var localGatewayData:ArrayCollection= new ArrayCollection();
			private var localSwitchData:ArrayCollection= new ArrayCollection();
			private var localWdsData:ArrayCollection= new ArrayCollection();
			private var localLocatorDeviceData:ArrayCollection= new ArrayCollection();
			
			public var floorPlanContextMenu:ContextMenu;
			private var floorPlanContextMenuItems:Array = [Constants.AUTO_LIGHT_LEVEL, Constants.ASSIGN_PROFILE, Constants.ASSIGN_SUITE, Constants.DEFINE_GROUP_BEHAVIOUR, Constants.DEFINE_SWITCH_BEHAVIOUR, Constants.DEFINE_MOTION_BITS_BEHAVIOUR, Constants.UNASSIGN_GROUPS, Constants.ASSIGN_USERS, Constants.SET_SWITCH_POSITION, Constants.CREATE_OTHER_DEVICES];
			
			private var commissionContextMenu:ContextMenu;
			private var commissionContextMenuItems:Array = [Constants.COMMISSION_AND_PLACE, Constants.RMA, Constants.CREATE_OTHER_DEVICES];
			
			public var m_propertyId:String;
			public var m_propertyType:String;
			public var m_propertyMode:String;
			public var m_propertyModeId:String;
			public var m_userRole:String;
			public var m_switchId:String;
			public var m_wdsId:String;
			public var m_groupId:String;
			public var m_fixtureVersion:String;
			public var m_enableMotionBits:String;
			private var m_dimmerSceneVal:String = "50";
			private var m_bCreateScene:Boolean = false;
			public var tempSwitchId:String = "";
			public var tempWdsId:String = "";
			public var tempGwId:String = "";
			
			[Bindable]
			public var fixtureDataReceivedAt:Date = null;
			
			private var fixtureDataReceived:Boolean = false;
			private var gatewayDataReceived:Boolean = false;
			private var locatorDeviceDataReceived:Boolean = false;
			
			private var layersDataGroup:ArrayCollection = new ArrayCollection([
				{label:"Light Level"},
				{label:"Fixture Status"},
				{label:"Ambient Status"},
				{label:"Occupancy Status"},
				{label:"Temperature Status"},
				{label:"Fixture Name"},
				{label:"Fixture MAC"},
				{label:"Fixture Area"},
				{label:"Motion Group"},
				{label:"Switch Group"},
				{label:"Fixture Profile"}
			]);
			
			private var reportsViewType:ArrayCollection = new ArrayCollection([
				{label:"All Fixtures"},
				{label:"Almost Dead"},
				{label:"Midlife Crisis"}
			]);
			
			[Bindable]
			private var gridDirection:String = "none";
			
			[Bindable]
			private var sceneDropDownArray:ArrayCollection = new ArrayCollection();
			
			/**
			 * GOLBAL VISIBILITY FLAGS FOR COMPONENT
			 */
			[Bindable]
			private var pinToolsWindow:Boolean = true;
			
			[Bindable]
			private var panEnabled:Boolean = false;
			
			[Bindable]
			private var floorplanMode:Boolean = false;
			
			[Bindable]
			private var showGridOptions:Boolean = true;
			
			[Bindable]
			private var showSearch:Boolean = true;
			
			[Bindable]
			public var showFilter:Boolean = false;
			
			[Bindable]
			public var reportVisibilityFlag:Boolean=false;
			
			[Bindable]
			public var showLockDragDrop:Boolean=false;
			
			[Bindable]
			public var showfpwrapper:Boolean=true; 
			
			[Bindable]
			public var showSelectionToolsWindow:Boolean=false;
			
			[Bindable]
			public var showSaveAsPdfButton:Boolean=false;
			
			[Bindable]
			public var showViewFilterBox:Boolean=true;
			
			[Bindable]
			public var showFloorPlanOuterContainer:Boolean=true;
			
			[Bindable]
			public var showLayersDropDown:Boolean=true;
			
			[Bindable]
			public var showViewLabel:Boolean=true;
			
			[Bindable]
			public var showMainContainer:Boolean=true;
			
			[Bindable]
			public var showToolbarViewStack:Boolean=true;
			
			private var nSceneIndex:int = -1;
			[Bindable]
			private var bMultipleGWs:Boolean = false;
			private var associatedGWId:int = -1;
			[Bindable]
			private var bWDSAssociated:Boolean = false;
			private var wdsGwId:int = -1;
			[Bindable]
			private var bSceneTestInProgress:Boolean = false;
			
			//GOLBAL VISIBILITY FLAGS FOR COMPONENT - ENDS
			
			[Bindable]
			public var widgetSelectedTab:String ="";
			private function onCreationComplete() : void
			{
				resetDevicePosition();
			}
			
			private function showToolsWindow(event:MouseEvent) : void
			{
				if(pinToolsWindow)
					return;
				else
				{
					if(event.stageX >= panCanvas.width - 1)
					{
						pinToolsWindow=true;
					}
					else if(slidingToolsWindow.visible && event.stageX > slidingToolsWindow.width)
					{
						pinToolsWindow=false;
					}
				} 
			}
			
			private function loadComplete(event:Event) : void
			{
				img.addEventListener(FlexEvent.UPDATE_COMPLETE, fitImageToScreen);
			}
			
			private function fitImageToScreen(event:FlexEvent) : void
			{
				minSliderValue = 100;
				img.scaleX = img.scaleY = floorPlanChart.scaleX = floorPlanChart.scaleY = 1;
				img.removeEventListener(FlexEvent.UPDATE_COMPLETE, fitImageToScreen);
				floorPlanChart.width = img.width;
				floorPlanChart.height = img.height;
				panCanvas.validateNow();
				for(var i:int=0; i<20; i++)
				{
					if(panCanvas.maxHorizontalScrollPosition > 0 || panCanvas.maxVerticalScrollPosition > 0)
					{
						minSliderValue = minSliderValue-5;
						zoomHandler();
					}
				}
				maxXaxis = img.width;
				maxYaxis = img.height;
				
				// TODO - handle radius
				//yaxis = img.height - fixturePlotSeries.radius;
				yaxis = img.height - 30;
			}
			
			private function addListeners() : void
			{
				if(showGridCB.selected)
				{
					snapToGrid.enabled = true;
				}
				floorPlanChart.addEventListener(MouseEvent.MOUSE_MOVE , onMouseMove);
				floorPlanChart.addEventListener(DragEvent.DRAG_ENTER, onDragEnter);
				floorPlanChart.addEventListener(DragEvent.DRAG_OVER , onDragOver);
				floorPlanChart.addEventListener(DragEvent.DRAG_DROP , onDragDrop);
				floorPlanChart.addEventListener(DragEvent.DRAG_EXIT , onDragExit);
			}
			
			private function removeListeners() : void
			{
				snapToGrid.enabled = false;				
				floorPlanChart.removeEventListener(MouseEvent.MOUSE_MOVE , onMouseMove);
				floorPlanChart.removeEventListener(DragEvent.DRAG_ENTER, onDragEnter);
				floorPlanChart.removeEventListener(DragEvent.DRAG_OVER , onDragOver);
				floorPlanChart.removeEventListener(DragEvent.DRAG_DROP , onDragDrop);
				floorPlanChart.removeEventListener(DragEvent.DRAG_EXIT , onDragExit);
			}
			
			private function clone( source:Object ) : *
			{
				var byteArray:ByteArray = new ByteArray();
				byteArray.writeObject( source );
				byteArray.position = 0;
				return byteArray.readObject();
			}
			
			public function resetDataOnFloorChange() : void
			{
				commissionedFixtureData.filterFunction = null;
				commissionedFixtureData.refresh();
				
				removeSelection();
				autoComplete.textInput.text = "";
				minSliderValue = 100;
				
				fixtureData.removeAll();
				commissionedFixtureData.removeAll();
				gatewayData.removeAll();
				commissionedGatewayData.removeAll();
				switchesData.removeAll();
				wdsData.removeAll();
				locatorDeviceData.removeAll();
								
				loadFloorPlan();
			}
			
			public function loadFloorPlan() : void
			{
				// NOTE: The floor plan will only be for floor, hence even for area we need to load its floor's floorplan
				// TODO: The property id should be area's floor id
				
				var imageURL:String = Constants.serverurl +  m_propertyType + "/" + m_propertyId +"?ts="+new Date();
				img.load(imageURL);
			}
			
			public function getFloorPlanData() : void
			{
				TXN_ID = new Date().getTime();
				handleChange(null);				
				searchData.removeAll();
				fixtureDataReceived = false;
				gatewayDataReceived = false;
				locatorDeviceDataReceived = false;
				var txnObj:Object = new Object();
				txnObj.transactionId = TXN_ID;
				txnObj.propertyMode = m_propertyMode;
				txnObj.propertyType = m_propertyType;
				
				if(m_propertyMode == Constants.FLOORPLAN)
				{
					if(!floorPlanChart.contextMenu)
						floorPlanChart.contextMenu = floorPlanContextMenu;
					
					motionGroupsListHttpService.url = Constants.serverurl + "motiongroup/list" + "/?ts=" + new Date().time;
					motionGroupsListHttpService.send();
					
					switchGroupsListHttpService.url = Constants.serverurl + "switchgroups/list" + "/?ts=" + new Date().time;
					switchGroupsListHttpService.send();
					
					locatorDeviceHttpService.url = Constants.serverurl + "locatordevice/list/" + m_propertyType + "/" + m_propertyId + "/?ts=" + new Date().time;
					locatorDeviceHttpService.send(txnObj);
					
					manageFloorPlanContextMenu();
					showSaveAsPdfButton=true;
				}
				
				if(m_propertyModeId == Constants.FIXTURE_COMMISSION)
				{
					locatorDeviceHttpService.url = Constants.serverurl + "locatordevice/list/" + m_propertyType + "/" + m_propertyId + "/?ts=" + new Date().time;
					locatorDeviceHttpService.send(txnObj);
				}
				
				if(m_propertyModeId == Constants.OUTAGE)
				{
					fixtureOutageHttpService.url = Constants.serverurl + "fixture/list/report/fixtureOutage/" + m_propertyType + "/" + m_propertyId + "/?ts=" + new Date().time;
					fixtureOutageHttpService.send(txnObj);
				}
				else
				{
					// Get Profile Data
					profileHttpService.url = Constants.serverurl + "profile/list/" + "?ts=" + new Date().time;
					profileHttpService.send(txnObj);
					
					fixtureHttpService.url = Constants.serverurl + "fixture/list/" + m_propertyType + "/" + m_propertyId + "/?ts=" + new Date().time;
					fixtureHttpService.send(txnObj);
				}
				
				if(m_propertyType == Constants.AREA)
				{
					switchHttpService.url = Constants.serverurl + "switch/list/" + m_propertyType + "/" + m_propertyId + "/?ts=" + new Date().time;
					switchHttpService.send(txnObj);
					
					if(FixtureIconRenderer.rendererType == Constants.FIXTURE_AREA)
						showFilter = false;
				}
				else if(m_propertyMode != Constants.REPORT)
				{
					gatewayHttpService.url = Constants.serverurl + "gateway/list/" + m_propertyType + "/" + m_propertyId + "/?ts=" + new Date().time;
					gatewayHttpService.send(txnObj);
					
					switchHttpService.url = Constants.serverurl + "switch/list/" + m_propertyType + "/" + m_propertyId + "/?ts=" + new Date().time;
					switchHttpService.send(txnObj);

					wdsHttpService.url = Constants.serverurl + "wds/list/" + m_propertyType + "/" + m_propertyId + "/?ts=" + new Date().time;
					wdsHttpService.send(txnObj);

					areaHttpService.url = Constants.serverurl + "area/list/" + m_propertyId + "/?ts=" + new Date().time;
					areaHttpService.send(txnObj);
					
					if(FixtureIconRenderer.rendererType == Constants.FIXTURE_AREA)
						showFilter = true;
					
					if(m_propertyMode==Constants.IMAGE_UPGRADE)
					{
						//Get the Image upgrade device status
						var currentDate:String = dateFormatter.format(new Date());
						getImageUpgradeDevicesStatus.url = Constants.serverurl + "imageupgrade/status" + "/" + currentDate;
						getImageUpgradeDevicesStatus.send(txnObj);
						//getImageUpgradeRunningStatus.url = Constants.serverurl + "imageupgrade/jobstatus" + "/?ts=" + new Date().time;
						//getImageUpgradeRunningStatus.send(txnObj);
					}
					if(m_propertyMode == Constants.SWITCH_MODE)
					{ 
						//check the last conectivity time with switch edit ox if excede the 
						updateSwitchGroupSyncFlag.url = Constants.serverurl + "switch/lastTimeValidation/?ts=" + new Date().time;
						updateSwitchGroupSyncFlag.send(txnObj);
						updateGroupSyncFlagTimer = new Timer(300000);
						updateGroupSyncFlagTimer.addEventListener(TimerEvent.TIMER, onUpdateGroupSyncFlagTimerComplete);
						updateGroupSyncFlagTimer.start();
					}
				}
				
				if(m_propertyMode == Constants.REPORT)
				{
					fixturePlotSeries.addEventListener(FlexEvent.UPDATE_COMPLETE, fpsUpdateComplete);
					fixturePlotSeries.dataProvider = commissionedFixtureData;
					layersDropDown.selectedIndex = 0;
				}
				
				if(FixtureIconRenderer.rendererType == Constants.MOTION_GROUP || FixtureIconRenderer.rendererType == Constants.SWITCH_GROUP)
				{
					filterDropDown.selectedIndex = -1;
					commissionedFixtureData.filterFunction = null;
					commissionedFixtureData.refresh();
				}

			}
			
			private function fpsUpdateComplete(event:FlexEvent) : void
			{
				if(m_propertyModeId == Constants.OUTAGE)
					createOutageFilters();
				else if(m_propertyModeId == Constants.BULB && mainContainer.visible)
					createBulbFilters();
			}
			
			public function setMode() : void
			{
				fixturePlotSeries.addEventListener(FlexEvent.UPDATE_COMPLETE, refreshFixturePlotSeries);
				gatewayPlotSeries.addEventListener(FlexEvent.UPDATE_COMPLETE, refreshGatewayPlotSeries);
				locatorDevicePlotSeries.addEventListener(FlexEvent.UPDATE_COMPLETE, refreshLocatorDevicePlotSeries);
				FixtureIconRenderer.rendererType = Constants.LIGHT_LEVEL;
				FixtureIconRenderer.imageStatus = Constants.LIGHT_LEVEL;
				
				// Get server time offset from GMT
				getServerGMTOffsetHttpService.url = Constants.serverurl + "getServerTimeOffsetFromGMT/" + "?ts=" + new Date().time;
				getServerGMTOffsetHttpService.send();
				
				showSelectionToolsWindow=false;
				
				if(m_propertyMode == Constants.FLOORPLAN)
				{
					floorplanMode = true;
					layersDropDown.dataProvider = layersDataGroup;
					layersDropDown.selectedIndex = 0;
					if(m_userRole && m_userRole != Constants.EMPLOYEE)
					{
						createFloorPlanContextMenu();
						showLockDragDrop=true;
					}
					else if(m_userRole && m_userRole == Constants.EMPLOYEE)
					{
						createFloorPlanContextMenu();
						showGridOptions = false;
					}
					floorPlanChart.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);
				}
				else if(m_propertyMode == Constants.COMMISSION)
				{
					showToolbarViewStack=false;
					createCommissionContextMenu();
					lockDragDrop.selected = false;
					showViewFilterBox=false;
					addListeners();
					floorPlanChart.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);
					FixtureIconRenderer.rendererType = Constants.FIXTURE_STATUS;
					FixtureIconRenderer.imageStatus = Constants.FIXTURE_STATUS;
				}
				else if(m_propertyMode == Constants.REPORT)
				{
					manageReportVisibility();
				} 
				else if(m_propertyMode == Constants.IMAGE_UPGRADE || m_propertyMode == Constants.SWITCH_MODE || m_propertyMode == Constants.GROUP_MODE || m_propertyMode == Constants.MOTION_BITS_GROUP_MODE)
				{
					manageImageUpgradeVisibility();
					if(m_propertyMode == Constants.SWITCH_MODE && widgetSelectedTab == Constants.LOCATION_TAB)
						createFloorPlanContextMenu();
				}
			}
			private function manageReportVisibility() : void
			{
				showGridOptions = false;
				showSearch = false;
				reportVisibilityFlag=true;
				showSaveAsPdfButton=true;
				showSelectionToolsWindow=false;
				
				if(m_propertyType == Constants.FLOOR)
				{
					showfpwrapper=true;
					showFloorPlanOuterContainer=true;
				}
				else
				{
					showfpwrapper=false;
					showFloorPlanOuterContainer=false;
				}
				reportsTableList.showView(m_propertyMode,"");
				
				if(m_propertyModeId == Constants.BULB)
				{
					layersDropDown.dataProvider = reportsViewType;
					layersDropDown.selectedIndex = 0;
				}
				else
				{
					showLayersDropDown=false;
					showFilter=false;
					showViewLabel=false;
				}
				
				FixtureIconRenderer.rendererType = Constants.FIXTURE_NAME;
			}
			
			private function manageImageUpgradeVisibility():void
			{
				showToolbarViewStack =false;
				
				if((m_propertyMode == Constants.SWITCH_MODE || m_propertyMode == Constants.GROUP_MODE || m_propertyMode == Constants.MOTION_BITS_GROUP_MODE) && widgetSelectedTab==Constants.LOCATION_TAB)
				{
					reportVisibilityFlag=false;
					showSelectionToolsWindow = false;
				}
				else
				{
					reportVisibilityFlag=true;
					showSelectionToolsWindow = true;
				}
				lockDragDrop.selected = false;
				showViewFilterBox=false;
				if(m_propertyType == Constants.FLOOR)
				{
					showfpwrapper=true;
					showFloorPlanOuterContainer=true;
					floorPlanChart.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);
					FixtureIconRenderer.rendererType = Constants.FIXTURE_MAC;
					FixtureIconRenderer.imageStatus = Constants.FIXTURE_STATUS;
					if(m_propertyMode != Constants.IMAGE_UPGRADE)
					{
						addListeners();
					}
				}
				else
				{
					showfpwrapper=false;
					showSelectionToolsWindow=false;
					showFloorPlanOuterContainer=false;
				}
				if((m_propertyMode == Constants.GROUP_MODE || m_propertyMode == Constants.MOTION_BITS_GROUP_MODE) || m_propertyType != Constants.FLOOR)
				{
					reportsTableList.showView(m_propertyMode, Constants.FIXTURE_TAB);
					handleTabClick(Constants.FIXTURE_TAB);
				}
				else
					reportsTableList.showView(m_propertyMode,"");

				reportsTableList.imageUpgradeFixtureGrid.selectedIndices=[];
				reportsTableList.imageUpGradeGatewayGrid.selectedIndices=[];
				reportsTableList.imageUpgradeWDSGrid.selectedIndices=[];
			}

			public function handleTabClick(tabName:String):void
			{
				removeSelection();
				
				if(tabName==Constants.LOCATION_TAB)
				{
					showToolbarViewStack =false;
					reportVisibilityFlag=false;
					showSelectionToolsWindow = false;
				}
				else if(tabName==Constants.FIXTURE_TAB)
				{
					if(m_propertyMode == Constants.SWITCH_MODE)
					{
						//As Fixture list is required in both Scene and Fixture Tab, Hence calling at root Level.
						getFixturesBySwitchIdHttpService.url = Constants.serverurl + "switch/getSwitchFixtures/" + m_switchId + "?ts=" + new Date().time;
						getFixturesBySwitchIdHttpService.send();
						
						//Reload WDS by Switch ID - Get the WDS list as well as we want to know if the WDS is associated or not
						getWDSsBySwitchIdHttpService.url = Constants.serverurl + "wds/list/switch/" + m_switchId + "?ts=" + new Date().time;
						getWDSsBySwitchIdHttpService.send();
					}
					else
					{
						fixturesByGroupIdHttpService.url = Constants.serverurl + "gemsgroupfixture/list/" + m_groupId + "/?ts=" + new Date().time;;;
						fixturesByGroupIdHttpService.send();
					}
					showToolbarViewStack =false;
					showSelectionToolsWindow = true;
					reportVisibilityFlag=true;
					reportsTableList.showView(m_propertyMode,widgetSelectedTab);
					
				}
				else if(tabName==Constants.SCENE_TAB)
				{
					// End the scene test on tab click
					bSceneTestInProgress = false;
					if(applyScene)
						applyScene.label = "Test scene";
					if(m_propertyMode == Constants.SWITCH_MODE)
					{
						//As Fixture list is required in both Scene and Fixture Tab, Hence calling at root Level.
						getFixturesBySwitchIdHttpService.url = Constants.serverurl + "switch/getSwitchFixtures/" + m_switchId + "?ts=" + new Date().time;
						getFixturesBySwitchIdHttpService.send();
					}
					else
					{
						fixturesByGroupIdHttpService.url = Constants.serverurl + "gemsgroupfixture/list/" + m_groupId + "/?ts=" + new Date().time;;;
						fixturesByGroupIdHttpService.send();
					}

					reportVisibilityFlag=true;
					showToolbarViewStack =true;
					toolbarViewStack.percentHeight = 20;
					toolbarViewStack.selectedIndex=1;
					reportsTableList.showView(m_propertyMode,widgetSelectedTab);
					showSelectionToolsWindow = false;
					
					getSceneBySwitchIdHttpService.url = Constants.serverurl + "scene/list/sid/" + m_switchId + "?ts=" + new Date().time;
					getSceneBySwitchIdHttpService.send();
				}
				else if(tabName==Constants.WDS_TAB)
				{
					reportVisibilityFlag=true;
					showToolbarViewStack =true;
					toolbarViewStack.percentHeight = 5;
					showSelectionToolsWindow = true;
					toolbarViewStack.selectedIndex=2;
					reportsTableList.showView(m_propertyMode,widgetSelectedTab);

					// Reload fixtures as well so that bMultipleGWs
					if(m_propertyMode == Constants.SWITCH_MODE)
					{
						//As Fixture list is required in both Scene and Fixture Tab, Hence calling at root Level.
						getFixturesBySwitchIdHttpService.url = Constants.serverurl + "switch/getSwitchFixtures/" + m_switchId + "?ts=" + new Date().time;
						getFixturesBySwitchIdHttpService.send();
					}

					//Reload WDS by Switch ID
					getWDSsBySwitchIdHttpService.url = Constants.serverurl + "wds/list/switch/" + m_switchId + "?ts=" + new Date().time;
					getWDSsBySwitchIdHttpService.send();
					
					commissionedFixtureData.filterFunction = null;
					commissionedFixtureData.refresh();
				}
			}
			
			public function hideFloorPlan() : void
			{
				if(m_propertyMode == Constants.IMAGE_UPGRADE || m_propertyMode == Constants.SWITCH_MODE || m_propertyMode == Constants.GROUP_MODE || m_propertyMode == Constants.MOTION_BITS_GROUP_MODE)
				{
					manageImageUpgradeVisibility();
				}
				else if(m_propertyMode == Constants.REPORT)
				{
					manageReportVisibility();
				}
				else
				{
					showViewFilterBox=false;
					showMainContainer=false;
				}
			}
			
			public function showFloorPlan() : void
			{
				if(m_propertyMode == Constants.IMAGE_UPGRADE || m_propertyMode == Constants.SWITCH_MODE || m_propertyMode == Constants.GROUP_MODE || m_propertyMode == Constants.MOTION_BITS_GROUP_MODE)
				{
					manageImageUpgradeVisibility();
				}
				else if(m_propertyMode == Constants.REPORT)
				{
					manageReportVisibility();
				}
				else
				{
					showViewFilterBox=true;
					showMainContainer=true;
				}
			}
			
			private function createBulbFilters() : void
			{
				almostDeadFixtureData.removeAll();
				midlifeFixtureData.removeAll();
				fullHealthFixtureData.removeAll();
				
				if(fixturePlotSeries.items.length == 0)
					return;
				
				fixturePlotSeries.removeEventListener(FlexEvent.UPDATE_COMPLETE, fpsUpdateComplete);
				
				for(var i:int = 0; i<commissionedFixtureData.length; i++)
				{
					var obj:Object = commissionedFixtureData.getItemAt(i);
					if (obj.bulblife < 25)
					{
						almostDeadFixtureData.addItem(obj);
						fixturePlotSeries.getChildAt(i).filters = [almostDeadGlowFilter];
					}						
					else if(obj.bulblife < 75 && obj.bulblife >= 25)
					{
						midlifeFixtureData.addItem(obj);
						fixturePlotSeries.getChildAt(i).filters = [midlifeGlowFilter];
					}
					else
					{
						fullHealthFixtureData.addItem(obj);
						fixturePlotSeries.getChildAt(i).filters = [fullHealthGlowFilter];
					}
				}
				searchData = new ArrayCollection(clone(commissionedFixtureData.source));
			}
			
			private function createOutageFilters() : void
			{
				
			}
			
			private function onGetFixture(event:ResultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				if(event.result == "")
					return;
				
				var asyncTxnObj:Object = event.token.message.body;
				
				if(asyncTxnObj && asyncTxnObj.transactionId != TXN_ID) {
					trace("Response discarded: " + asyncTxnObj.transactionId + ", " + TXN_ID);
					return;
				}
				
				commissionedFixtureData.disableAutoUpdate();
				fixtureData.removeAll();
				commissionedFixtureData.removeAll();
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				var tempData:ArrayCollection = new ArrayCollection();
				(resultObj.fixtures.fixture is ArrayCollection) ? (tempData = resultObj.fixtures.fixture) :  (tempData.addItem(resultObj.fixtures.fixture));
				
				for each(var fixtureObj:Object in tempData)
				{
					var versionNumber:Number;
					var versionArr:Array
					
					versionArr = fixtureObj.version.split(".")

					if(m_propertyMode == Constants.GROUP_MODE && m_groupId != "" && m_fixtureVersion != "")
					{
						versionNumber = Number(versionArr[0]+"."+versionArr[1]);
						if(m_fixtureVersion == "1.5" && (versionNumber >= 1.5 && versionNumber < 2.0))
							(fixtureObj.state == Constants.COMMISSIONED) ? (commissionedFixtureData.addItem(fixtureObj)) : (fixtureData.addItem(fixtureObj))
						else if(m_fixtureVersion == "2.0" && versionNumber >= 2.0)
							(fixtureObj.state == Constants.COMMISSIONED) ? (commissionedFixtureData.addItem(fixtureObj)) : (fixtureData.addItem(fixtureObj))
					} 
					else if(m_propertyMode == Constants.SWITCH_MODE && m_switchId != "" && m_fixtureVersion != "")
					{
						versionNumber = Number(versionArr[0]);
						if(m_fixtureVersion.toUpperCase() == "1.X" && (versionNumber >= 1 && versionNumber < 2))
							(fixtureObj.state == Constants.COMMISSIONED) ? (commissionedFixtureData.addItem(fixtureObj)) : (fixtureData.addItem(fixtureObj))
						else if(m_fixtureVersion.toLocaleUpperCase() == "2.X" && versionNumber >= 2)
							(fixtureObj.state == Constants.COMMISSIONED) ? (commissionedFixtureData.addItem(fixtureObj)) : (fixtureData.addItem(fixtureObj))
					}
					else if(m_propertyMode == Constants.MOTION_BITS_GROUP_MODE && m_groupId != "")
					{
						versionNumber = Number(versionArr[0]+"."+versionArr[1]);
						if(versionNumber >= 2.0)
							(fixtureObj.state == Constants.COMMISSIONED) ? (commissionedFixtureData.addItem(fixtureObj)) : (fixtureData.addItem(fixtureObj))
					}
					else
						(fixtureObj.state == Constants.COMMISSIONED) ? (commissionedFixtureData.addItem(fixtureObj)) : (fixtureData.addItem(fixtureObj))

					fixtureObj.type = Constants.FIXTURE;
					
					if(fixtureObj.upgradestatus == null)
						fixtureObj.upgradestatus = "";
					
					var profileObj:Object = getProfileDataById(fixtureObj.groupid);
					//If default profile is there, then rename the default profiles with suffix "_default"
					if(profileObj!=null && profileObj.defaultProfile==true && profileObj.profileNo>0)
					{
						fixtureObj.currentprofile = setDefaultProfileName(fixtureObj.currentprofile);
					}
				} 
				
				if(m_propertyMode == Constants.REPORT)
				{
					reportsTableList.reportTableGrid.dataProvider = commissionedFixtureData;
				}
				
				// Set the time that data was received in FixtureItemRenderer
				fixtureDataReceivedAt = new Date();
				fixtureDataReceived = true;
				
				commissionedFixtureData.enableAutoUpdate();
				
				if(selectedFixtures.length > 0)
				{
					var id:int;
					for(var j:int=0; j<selectedFixtures.length; j++)
					{
						if(selectedFixtures[j] is PlotSeriesItem)
						{
							id = selectedFixtures[j].item.id;
						}
						else
						{
							id = selectedFixtures[j].id;
						}
						for each (var obj:Object in commissionedFixtureData)
						{
							if(obj.id == id)
							{
								selectedFixtures[j].item = obj;
								break;
							}
						}
					}
				}
				searchData = new ArrayCollection(searchData.toArray().concat(commissionedFixtureData.toArray()));
				// Sort only when all three are recieved
				if(fixtureDataReceived && gatewayDataReceived)
					sortData(searchData, "name");

			}
			
			private function onGetFixtureFailure(event:FaultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onGetGateway(event:ResultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				if(event.result == "")
					return;
				
				var asyncTxnObj:Object = event.token.message.body;
				if(asyncTxnObj && asyncTxnObj.transactionId != TXN_ID) {
					trace("Response discarded: " + asyncTxnObj.transactionId + ", " + TXN_ID);
					return;
				}
				
				gatewayData.removeAll();
				commissionedGatewayData.removeAll();
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				var tempData:ArrayCollection = new ArrayCollection();
				(resultObj.gateways.gateway is ArrayCollection) ? (tempData = resultObj.gateways.gateway) : (tempData.addItem(resultObj.gateways.gateway));
				
				for each(var gatewayObj:Object in tempData)
				{
					(gatewayObj.commissioned) ? (commissionedGatewayData.addItem(gatewayObj)) : (gatewayData.addItem(gatewayObj));
					gatewayObj.type = Constants.GATEWAY;
					if(gatewayObj.upgradestatus == null)
						gatewayObj.upgradestatus = "";
				}
				
				commissionedGatewayData.enableAutoUpdate();
				gatewayDataReceived = true;
					
				if(selectedGateways.length > 0)
				{
					var id:int;
					for(var j:int=0; j<selectedGateways.length; j++)
					{
						if(selectedGateways[j] is PlotSeriesItem)
						{
							id = selectedGateways[j].item.id;
						}
						else
						{
							id = selectedGateways[j].id;
						}
						for each (var obj:Object in commissionedGatewayData)
						{
							if(obj.id == id)
							{
								selectedGateways[j].item = obj;
								break;
							}
						}
					}
				}
				
				searchData = new ArrayCollection(searchData.toArray().concat(commissionedGatewayData.toArray()));
				// Sort only when all three are recieved
				if(fixtureDataReceived && gatewayDataReceived)
					sortData(searchData, "name");
			}
			
			private function onGetGatewayFailure(event:FaultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onGetLocatorDevice(event:ResultEvent) : void{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				if(event.result == "")
					return;
				
				var asyncTxnObj:Object = event.token.message.body;
				if(asyncTxnObj && asyncTxnObj.transactionId != TXN_ID) {
					trace("Response discarded: " + asyncTxnObj.transactionId + ", " + TXN_ID);
					return;
				}
				
				locatorDeviceData.disableAutoUpdate();
				locatorDeviceData.removeAll();
				
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				var tempData:ArrayCollection = new ArrayCollection();
				
				(resultObj.locatorDevices.locatorDevice is ArrayCollection) ? (tempData = resultObj.locatorDevices.locatorDevice) : (tempData.addItem(resultObj.locatorDevices.locatorDevice));
				
				for each(var locatorDeviceObj:Object in tempData)
				{
					locatorDeviceData.addItem(locatorDeviceObj);
					locatorDeviceObj.type = Constants.LOCATORDEVICE;
				}
				
				locatorDeviceData.enableAutoUpdate();
				locatorDeviceDataReceived = true;
				
				if(selectedLocatorDevices.length > 0)
				{
					var id:int;
					for(var j:int=0; j<selectedLocatorDevices.length; j++)
					{
						if(selectedLocatorDevices[j] is PlotSeriesItem)
						{
							id = selectedLocatorDevices[j].item.id;
						}
						else
						{
							id = selectedLocatorDevices[j].id;
						}
						for each (var obj:Object in locatorDeviceData)
						{
							if(obj.id == id)
							{
								selectedLocatorDevices[j].item = obj;
								break;
							}
						}
					}
				}
				
				searchData = new ArrayCollection(searchData.toArray().concat(locatorDeviceData.toArray()));
				// Sort only when all three are recieved
				if(fixtureDataReceived && gatewayDataReceived)
					sortData(searchData, "name");
			}
			
			private function onGetLocatorDeviceFailure(event:FaultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onGetSwitch(event:ResultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				if(event.result == "")
					return;
				
				var asyncTxnObj:Object = event.token.message.body;
				if(asyncTxnObj && asyncTxnObj.transactionId != TXN_ID) {
					trace("Response discarded: " + asyncTxnObj.transactionId + ", " + TXN_ID);
					return;
				}
				switchesData.disableAutoUpdate();
				switchesData.removeAll();
				
				var str:String = event.result.toString();
				var pattern:RegExp = /switch>/gi;
				var xmlString:String = str.replace(pattern, "vswitch>");
				var xml:XMLDocument = new XMLDocument(xmlString);
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);

				var tempData:ArrayCollection = new ArrayCollection();
				(resultObj.switches.vswitch is ArrayCollection) ? (tempData = resultObj.switches.vswitch) :  (tempData.addItem(resultObj.switches.vswitch));

				for each(var switchObj:Object in tempData)
				{
					switchesData.addItem(switchObj);
					switchObj.type = Constants.SWITCH;
				}

				switchesData.enableAutoUpdate();
				
				if(selectedSwitches.length > 0)
				{
					var id:int;
					for(var j:int=0; j<selectedSwitches.length; j++)
					{
						if(selectedSwitches[j] is PlotSeriesItem)
						{
							id = selectedSwitches[j].item.id;
						}
						else
						{
							id = selectedSwitches[j].id;
						}
						for each (var obj:Object in switchesData)
						{
							if(obj.id == id)
							{
								selectedSwitches[j].item = obj;
								break;
							}
						}
					}
				}
				
				switchPlotSeries.addEventListener(FlexEvent.UPDATE_COMPLETE, refreshSwitchPlotSeries);

				searchData = new ArrayCollection(searchData.toArray().concat(switchesData.toArray()));
				// Sort only when all three are recieved
				if(fixtureDataReceived && gatewayDataReceived)
					sortData(searchData, "name");
			}
			
			private function onGetSwitchFailure(event:FaultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}

			private function onGetWds(event:ResultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				if(event.result == "")
					return;
				
				var asyncTxnObj:Object = event.token.message.body;
				if(asyncTxnObj && asyncTxnObj.transactionId != TXN_ID) {
					trace("Response discarded: " + asyncTxnObj.transactionId + ", " + TXN_ID);
					return;
				}
				wdsData.disableAutoUpdate();
				wdsData.removeAll();
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);

				var tempData:ArrayCollection = new ArrayCollection();
				(resultObj.wdss.wds is ArrayCollection) ? (tempData = resultObj.wdss.wds) :  (tempData.addItem(resultObj.wdss.wds));
				for each(var wdsObj:Object in tempData)
				{
					// When in SWITCH_MODE; user shouldn't see WDSs which are already associated with other switches
					if(m_propertyMode == Constants.SWITCH_MODE && m_switchId != "")
					{
						if((wdsObj.switchId == m_switchId) || (wdsObj.associationstate && wdsObj.associationstate == 0))
						{
							wdsData.addItem(wdsObj);
						}
					}
					else
					{
						wdsData.addItem(wdsObj);
					}
					wdsObj.type = Constants.WDS;
					if(wdsObj.upgradestatus == null)
						wdsObj.upgradestatus = "";
				}

				wdsData.enableAutoUpdate();
				
				if(selectedWds.length > 0)
				{
					var id:int;
					for(var j:int=0; j<selectedWds.length; j++)
					{
						if(selectedWds[j] is PlotSeriesItem)
						{
							id = selectedWds[j].item.id;
						}
						else
						{
							id = selectedWds[j].id;
						}
						for each (var obj:Object in wdsData)
						{
							if(obj.id == id)
							{
								selectedWds[j].item = obj;
								break;
							}
						}
					}
				}
				
				wdsPlotSeries.addEventListener(FlexEvent.UPDATE_COMPLETE, refreshWdsPlotSeries);
			}
			
			private function onGetWdsFailure(event:FaultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}

			
			private function onGetArea(event:ResultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				var asyncTxnObj:Object = event.token.message.body;
				if(asyncTxnObj && asyncTxnObj.transactionId != TXN_ID) {
					trace("Response discarded: " + asyncTxnObj.transactionId + ", " + TXN_ID);
					return;
				}
				
				areaData.removeAll();
				if(event.result == "")
				{
					floorPlanChart.contextMenu = floorPlanContextMenu;
					if(layersDropDown.selectedItem && layersDropDown.selectedItem.label == Constants.FIXTURE_AREA)
					{
						createAreaFilterData();
					}
					return;
				}
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				if(resultObj.areas.area is ArrayCollection)
				{
					areaData = resultObj.areas.area;
				}
				else
				{
					areaData.addItem(resultObj.areas.area);
				}
				
				if(layersDropDown.selectedItem && layersDropDown.selectedItem.label == Constants.FIXTURE_AREA)
				{
					createAreaFilterData();
				}
			}
			
			private function onGetAreaFailure(event:FaultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onGetProfile(event:ResultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				var asyncTxnObj:Object = event.token.message.body;
				if(asyncTxnObj && asyncTxnObj.transactionId != TXN_ID) {
					trace("Response discarded: " + asyncTxnObj.transactionId + ", " + TXN_ID);
					return;
				}
				
				profileData.removeAll();
				if(event.result == "")
				{
					floorPlanChart.contextMenu = floorPlanContextMenu;
					if(layersDropDown.selectedItem && layersDropDown.selectedItem.label == Constants.FIXTURE_PROFILE)
					{
						createProfileFilterData();
					}
					return;
				}
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				if(resultObj.groupss.group is ArrayCollection)
				{
					profileData = resultObj.groupss.group;
				}
				else
				{
					profileData.addItem(resultObj.groupss.group);
				}
				
				if(layersDropDown.selectedItem && layersDropDown.selectedItem.label == Constants.FIXTURE_PROFILE)
				{
					createProfileFilterData();
				}
			}
			
			private function onGetProfileFailure(event:FaultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function getServerGMTOffsetResult(event:ResultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				serverGMTOffset = event.result.valueOf();
			}
			
			private function getServerGMTOffsetFailure(event:FaultEvent) : void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function sortData( data:ArrayCollection, sortString:String) : ArrayCollection
			{
				var sortField:SortField  = new SortField();
				sortField.name = sortString;
				
				var sort:Sort = new Sort();
				sort.fields = [sortField];
				
				data.sort = sort;
				data.refresh();

				return data;
			}
			
			/* private var scaleXValue:Number = 1;
			private var scaleYValue:Number = 1; */
			
			private function zoomHandler():void 
			{
				FlexGlobals.topLevelApplication.removeMarquee()
				floorPlanChart.scaleX = slider.value/100;
				floorPlanChart.scaleY = slider.value/100;
				
				img.scaleX = slider.value/100;
				img.scaleY = slider.value/100;
				
				validateNow();
				
				/* scaleXValue = img.scaleX;
				scaleYValue = img.scaleY;
				
				img.scaleX = slider.value/100;
				img.scaleY = slider.value/100;
				
				floorPlanChart.width = (img.width / scaleXValue) * img.scaleX;
				floorPlanChart.height = (img.height / scaleYValue) * img.scaleY;
				
				for(var l:int = 0; l<commissionedFixtureData.length; l++)
				{
				commissionedFixtureData[l].xaxis = (commissionedFixtureData[l].xaxis / scaleXValue) * img.scaleX;
				commissionedFixtureData[l]yaxis = commissionedFixtureData[l].yaxis * img.scaleY;
				} */
			}
			
			private function zoom( event:MouseEvent, str:String ) : void
			{
				FlexGlobals.topLevelApplication.removeMarquee();
				switch(str)
				{
					case "doubleClick" : 
						if(event.target is Image)
							return;
						slider.value = slider.value + 25;
						break;
					
					case "mouseWheel" : 
						event.stopImmediatePropagation();
						slider.value = (event.delta > 0) ? (slider.value + 25) : (slider.value - 25);
						break;
					
					case "originalSize" : 
						slider.value = slider.minimum;
						break;
				}
				
				if(slider.value > slider.maximum)
				{
					slider.value = slider.maximum;
					return;
				}
				
				if(slider.value < slider.minimum)
				{
					slider.value = slider.minimum;
					return;
				}
				
				zoomHandler();
				
				var initHorizontalScrollPosition:int = panCanvas.horizontalScrollPosition;
				var initVerticalScrollPosition:int = panCanvas.verticalScrollPosition;
				
				var stagePoint:Point = new Point();
				stagePoint.x = event.stageX;
				stagePoint.y = event.stageY;
				
				var localPoint:Point = panCanvas.globalToLocal(stagePoint);
				panCanvas.horizontalScrollPosition = initHorizontalScrollPosition + localPoint.x - (panCanvas.width/2);
				panCanvas.verticalScrollPosition = initVerticalScrollPosition + localPoint.y - (panCanvas.height/2);
			}
			
			public function addFixture(orgType:String, orgId:String, fixtureId:String, bRMAInProgress:Boolean) : void
			{
				var oFixture:Object = null;
				
				// If RMA is in progress then we neither need to add the fixture to the commissionedFixture list nor we need 
				// to position the fixture. We just need to get the fixture details so refresh the floor plan 
				if(bRMAInProgress == true)
				{
					getFloorPlanData();
					return;
				}
				
				for(var i:int=0; i<fixtureData.length; i++)
				{
					if(fixtureData[i].id == fixtureId)
					{
						if (devicePosition.x > 0 && devicePosition.y > 0) 
						{
							fixtureData[i].xaxis = devicePosition.x;
							fixtureData[i].yaxis = devicePosition.y;
						} else {
							fixtureData[i].xaxis = int((panCanvas.horizontalScrollPosition) / (floorPlanChart.scaleX) + (12 * floorPlanChart.scaleX)) + 30;
							fixtureData[i].yaxis = int(maxYaxis - (panCanvas.verticalScrollPosition) / (floorPlanChart.scaleY) - (12 * floorPlanChart.scaleY)) - 30;
						}
						resetDevicePosition();
						fixtureData[i].state = Constants.COMMISSIONED;
						oFixture = fixtureData[i];
						commissionedFixtureData.addItem(fixtureData[i]);
						fixtureData.removeItemAt(i);
						break;
					}
				}
				
				if (oFixture != null) 
				{
					FlexGlobals.topLevelApplication.showAlertMarquee("Positioning fixture " + oFixture.id + ", " + oFixture.xaxis + ", " + oFixture.yaxis, true);
					
					var fixtureXmlList:XML = XML("<fixtures><fixture><id>" + fixtureId + "</id><xaxis>" + oFixture.xaxis + "</xaxis><yaxis>" + oFixture.yaxis + "</yaxis></fixture></fixtures>");
					
					updateFixturePositionHttpService.url = Constants.serverurl + "fixture/du/updateposition" + "/?ts=" + new Date().time;
					updateFixturePositionHttpService.request = fixtureXmlList;
					updateFixturePositionHttpService.send();
				}
				commissionedFixtureData.refresh();
			}
			
			public function addGateway(orgType:String, orgId:String, gatewayId:String) : void
			{
				var oGateway:Object = null;
				for(var i:int=0; i<gatewayData.length; i++)
				{
					if(gatewayData[i].id == gatewayId)
					{
						if (devicePosition.x > 0 && devicePosition.y > 0) 
						{
							gatewayData[i].xaxis = devicePosition.x;
							gatewayData[i].yaxis = devicePosition.y;
						} else { 
							gatewayData[i].xaxis = int((panCanvas.horizontalScrollPosition) / (floorPlanChart.scaleX) + (12 * floorPlanChart.scaleX)) + 30;
							gatewayData[i].yaxis = int(maxYaxis - (panCanvas.verticalScrollPosition) / (floorPlanChart.scaleY) - (12 * floorPlanChart.scaleY)) - 30;
						}
						resetDevicePosition();
						gatewayData[i].state = Constants.COMMISSIONED;
						oGateway = gatewayData[i];
						commissionedGatewayData.addItem(gatewayData[i]);
						gatewayData.removeItemAt(i);
						break;
					}
				}
				
				if(oGateway)
				{
					FlexGlobals.topLevelApplication.showAlertMarquee("Positioning gateway " + oGateway.id + ", " + oGateway.xaxis + ", " + oGateway.yaxis, true);
					
					var gatewayXmlList:XML = XML("<gateways><gateway><id>" + gatewayId + "</id><xaxis>" + oGateway.xaxis + "</xaxis><yaxis>" + oGateway.yaxis + "</yaxis></gateway></gateways>");
					
					updateGatewayPositionHttpService.url = Constants.serverurl + "gateway/du/updateposition" + "/?ts=" + new Date().time;
					updateGatewayPositionHttpService.request = gatewayXmlList;
					updateGatewayPositionHttpService.send();
					commissionedGatewayData.refresh();
				}
				else
				{
					getGatewayDeatilsHttpService.url= Constants.serverurl + "gateway/details/" + gatewayId + "/?ts=" + new Date().time;
					getGatewayDeatilsHttpService.send();
				}
				
			}
			
			public function addLocatorDevice() : void
			{
				
				refreshLocatorDevicesOnPlotChart();
			}
			
			public function updateLocatorDevice():void
			{
				refreshLocatorDevicesOnPlotChart();
			}
			
			public function refreshLocatorDevicesOnPlotChart():void
			{
				if(m_propertyMode == Constants.COMMISSION || m_propertyMode == Constants.FLOORPLAN )
				{
					TXN_ID = new Date().getTime();
					var txnObj:Object = new Object();
					txnObj.transactionId = TXN_ID;
					txnObj.propertyMode = m_propertyMode;
					txnObj.propertyType = m_propertyType;
					locatorDeviceHttpService.url = Constants.serverurl + "locatordevice/list/"+m_propertyType+"/" + m_propertyId + "/?ts=" + new Date().time;
					locatorDeviceHttpService.send(txnObj);
				}
			}
			
			public function addSwitch(orgType:String, orgId:String, switchId:String) : void
			{
				var oSwitch:Object = null;
				for(var i:int=0; i<switchesData.length; i++)
				{
					if(switchesData[i].id == switchId)
					{
						if (devicePosition.x > 0 && devicePosition.y > 0) 
						{
							switchesData[i].xaxis = devicePosition.x;
							switchesData[i].yaxis = devicePosition.y;
						} else { 
							switchesData[i].xaxis = int((panCanvas.horizontalScrollPosition) / (floorPlanChart.scaleX) + (12 * floorPlanChart.scaleX)) + 30;
							switchesData[i].yaxis = int(maxYaxis - (panCanvas.verticalScrollPosition) / (floorPlanChart.scaleY) - (12 * floorPlanChart.scaleY)) - 30;
						}
						resetDevicePosition();
						switchesData[i].state = Constants.COMMISSIONED;
						oSwitch = switchesData[i];
						break;
					}
				}
				
				if(oSwitch)
				{
					FlexGlobals.topLevelApplication.showAlertMarquee("Positioning switch " + oSwitch.id + ", " + oSwitch.xaxis + ", " + oSwitch.yaxis, true);
					
					var switchXmlList:XML = XML("<switches><switch><id>" + switchId + "</id><xaxis>" + oSwitch.xaxis + "</xaxis><yaxis>" + oSwitch.yaxis + "</yaxis></switch></switches>");
					
					updateSwitchPositionHttpService.url = Constants.serverurl + "switch/du/updateposition" + "/?ts=" + new Date().time;
					updateSwitchPositionHttpService.request = switchXmlList;
					updateSwitchPositionHttpService.send();
					switchesData.refresh();
				}
				else
				{
					//getSwitchDeatilsHttpService.url= Constants.serverurl + "switch/details/" + switchId + "/?ts=" + new Date().time;
					//getSwitchDeatilsHttpService.send();
					// TODO: optimize to update one switch
					switchHttpService.url = Constants.serverurl + "switch/list/" + m_propertyType + "/" + m_propertyId + "/?ts=" + new Date().time;
					switchHttpService.send();
				}
			}
			
			public function addWds(orgType:String, orgId:String, wdsId:String, switchId:String, gwId:String) : void
			{
				var oWds:Object = new Object();
				oWds.id = wdsId;
//				for(var i:int=0; i<wdsData.length; i++)
//				{
//					if(wdsData[i].id == wdsId)
//					{
						if (devicePosition.x > 0 && devicePosition.y > 0) 
						{
							oWds.xaxis = devicePosition.x;
							oWds.yaxis = devicePosition.y;
						} else { 
							oWds.xaxis = int((panCanvas.horizontalScrollPosition) / (floorPlanChart.scaleX) + (12 * floorPlanChart.scaleX)) + 30;
							oWds.yaxis = int(maxYaxis - (panCanvas.verticalScrollPosition) / (floorPlanChart.scaleY) - (12 * floorPlanChart.scaleY)) - 30;
						}
						resetDevicePosition();
						oWds.state = Constants.COMMISSIONED;
						wdsData.addItem(oWds);
//						oWds = wdsData[i];
//						break;
//					}
//				}
				
				if(oWds)
				{
					FlexGlobals.topLevelApplication.showAlertMarquee("Positioning wds " + oWds.id + ", " + oWds.xaxis + ", " + oWds.yaxis, true);
					
					var wdsXmlList:XML = XML("<wdss><wds><id>" + wdsId + "</id><xaxis>" + oWds.xaxis + "</xaxis><yaxis>" + oWds.yaxis + "</yaxis></wds></wdss>");
					
					updateWdsPositionHttpService.url = Constants.serverurl + "wds/du/updateposition" + "/?ts=" + new Date().time;
					updateWdsPositionHttpService.request = wdsXmlList;
					updateWdsPositionHttpService.send();
					wdsData.refresh();
				}

				// When the WDS is being added from switch widget then switchID is not null. Here get the list of already associated
				// with the switch and then add this wds to the switch
				if(switchId != "")
				{
					tempSwitchId = switchId;
					tempWdsId = wdsId;
					tempGwId = gwId;

					getWDSsBySwitchIdHttpService.url = Constants.serverurl + "wds/list/switch/" + switchId + "?ts=" + new Date().time;
					getWDSsBySwitchIdHttpService.send();
				}
				
				// TODO: optimize this to reduce entire refresh
//				refreshFloorPlan();
			}

			public function selectFixture(fixtureId:String) : void
			{
				var oFixture:Object;
//				removeSelection();
				for(var l:int=0; l<commissionedFixtureData.length; l++)
				{
					if(commissionedFixtureData[l].id == fixtureId)
					{
						oFixture = commissionedFixtureData[l];
						selectedItems.push(commissionedFixtureData[l]);
						selectedFixtures.addItem(commissionedFixtureData[l]);
						applyFilters(oFixture, "glowFilter");
						break;
					}
				}
			}

			public function selectGateway(gatewayId:String) : void
			{
				var oGateway:Object;
				removeSelection();
				for(var l:int=0; l<commissionedGatewayData.length; l++)
				{
					if(commissionedGatewayData[l].id == gatewayId)
					{
						oGateway = commissionedGatewayData[l];
						selectedItems.push(commissionedGatewayData[l]);
						selectedFixtures.addItem(commissionedGatewayData[l]);
						applyFilters(oGateway, "glowFilter");
						break;
					}
				}
			}
			
			public function selectWDS(wdsId:String) : void
			{
				var oWDS:Object;
				removeSelection();
				for(var l:int=0; l<wdsData.length; l++)
				{
					if(wdsData[l].id == wdsId)
					{
						oWDS = wdsData[l];
						selectedItems.push(wdsData[l]);
						selectedWds.addItem(wdsData[l]);
						applyFilters(oWDS, "glowFilter");
						break;
					}
				}
			}
			
			public function selectLocatorDevice(locatorDeviceId:String) : void
			{
				var oLocatorDevice:Object;
				removeSelection();
				for(var l:int=0; l<locatorDeviceData.length; l++)
				{
					if(locatorDeviceData[l].id == locatorDeviceId)
					{
						oLocatorDevice = locatorDeviceData[l];
						selectedItems.push(locatorDeviceData[l]);
						selectedLocatorDevices.addItem(locatorDeviceData[l]);
						applyFilters(oLocatorDevice, "glowFilter");
						break;
					}
				}
			}

			private function onMouseDown(event:MouseEvent) : void
			{
				if(panEnabled)
					floorPlanChart.selectionMode = event.ctrlKey ? "multiple" : "single";
				
				panCanvas.addEventListener(MouseEvent.MOUSE_UP, handleChange);
			}
			
			private function onMouseMove( event:MouseEvent ):void
			{
				if(event.target is Image)
				{
					/** 
					 * Item renderer of the plot series is the drag initiator
					 **/ 
					var dragInitiator:UIComponent = event.target.parent as UIComponent;
					
					// In switch mode 
					if(m_propertyMode == Constants.SWITCH_MODE && m_switchId != "" && widgetSelectedTab == Constants.LOCATION_TAB)
					{
						if(event.target.parent.data.item.id != m_switchId)
							return;
					}
					
					/**
					 * Adding the item renderer of the plot series as the dragSource. 
					 * DragSource will contain the data of fixture/switch/gateway
					 **/
					var dragSource:DragSource = new DragSource();
					var format:String = event.target.parent.name;
					dragSource.addData(event.target.parent.data.item, format);
					var dragProxy:Image = new Image();
					dragProxy.source = event.target.source;
					dragProxy.width = 16;
					dragProxy.height = 16;
					
					DragManager.doDrag(dragInitiator, dragSource, event, dragProxy, 
						dragInitiator.width/2 - dragInitiator.contentMouseX, dragInitiator.height/2 - dragInitiator.contentMouseY);
					
					// This check is required because if the item which is not selected is being dragged then the selected items also get 
					// dragged. So clear the selected item first. But we need to do this only when dragging ( that is primary key down) and
					// not for the general mouse move.
					if(event.buttonDown == true && (selectedItems.length == 0 || selectedItems.length == 1))						
						handleChange(event);
				} 
			}
			
			private function onDragEnter(event:DragEvent) : void
			{
				event.preventDefault();
				DragManager.acceptDragDrop(event.target as UIComponent);
				DragManager.showFeedback(DragManager.COPY);
			}
			
			private function onDragOver(event:DragEvent) : void
			{
				event.preventDefault();				
				event.currentTarget.showDropFeedback(event);
			}
			
			private function onDragDrop(event:DragEvent) : void
			{
				// Remove the blue border that is shown aroud the drop target
				event.currentTarget.hideDropFeedback(event);
				
				var obj:Object = new Object();
				
				if(event.dragInitiator.name == Constants.FIXTURE_RENDERER)
				{
					obj = event.dragSource.dataForFormat(Constants.FIXTURE_RENDERER) as Object;
				}
				else if(event.dragInitiator.name == Constants.GATEWAY_RENDERER)
				{
					obj = event.dragSource.dataForFormat(Constants.GATEWAY_RENDERER) as Object;
				}
				else if(event.dragInitiator.name == Constants.SWITCH_RENDERER)
				{
					obj = event.dragSource.dataForFormat(Constants.SWITCH_RENDERER) as Object;
				}
				else if(event.dragInitiator.name == Constants.WDS_RENDERER)
				{
					obj = event.dragSource.dataForFormat(Constants.WDS_RENDERER) as Object;
				}
				else if(event.dragInitiator.name == Constants.LOCATOR_DEVICE_RENDERER)
				{
					obj = event.dragSource.dataForFormat(Constants.LOCATOR_DEVICE_RENDERER) as Object;
				}
				
				var oldXaxis:int = obj.xaxis;
				var oldYaxis:int = obj.yaxis; 
				
				var point:ArrayCollection = new ArrayCollection(fixturePlotSeries.localToData(new Point(floorPlanChart.mouseX,floorPlanChart.mouseY)));
				
				var newXaxis:int = point[0];
				var newYaxis:int = point[1]; 
				
				var xaxisDiff:int = oldXaxis - newXaxis;
				var yaxisDiff:int = oldYaxis - newYaxis;
				
				dropDevice( false, xaxisDiff, yaxisDiff);
			}
			
			private function dropDevice( allowSnapToGrid:Boolean, xaxisDiff:int, yaxisDiff:int) : void
			{
				createLocalData();
				resetData();
				
				for(var i:int=0; i<selectedItems.length; i++)
				{
					var obj:Object;
					if(selectedItems[i] is PlotSeriesItem)
					{
						obj = selectedItems[i].item
					}
					else
					{
						obj = selectedItems[i];
					}
					
					if(allowSnapToGrid)
					{
						obj.xaxis = roundValue( gridPixels, obj.xaxis );
						obj.yaxis = roundValue( gridPixels, obj.yaxis );
					}
					else
					{
						obj.xaxis = obj.xaxis - xaxisDiff;
						obj.yaxis = obj.yaxis - yaxisDiff;
					}
					
					if(obj.xaxis < 0)
						obj.xaxis = 0;
					else if(obj.xaxis > maxXaxis)
						obj.xaxis = maxXaxis;
					
					if(obj.yaxis < 0)
						obj.yaxis = 0;
					else if(obj.yaxis > maxYaxis)
						obj.yaxis = maxYaxis;
					
					if(obj.type == Constants.FIXTURE)
						selectedFixtures.addItem(obj);
					else if(obj.type == Constants.GATEWAY)
						selectedGateways.addItem(obj);
					else if(obj.type == Constants.SWITCH)
						selectedSwitches.addItem(obj);
					else if(obj.type == Constants.WDS)
						selectedWds.addItem(obj);
					else if(obj.type == Constants.LOCATORDEVICE)
						selectedLocatorDevices.addItem(obj);
				}
				
				if(selectedFixtures.length > 0)
					updateFixturePosition(selectedFixtures);
				if(selectedGateways.length > 0)
					updateGatewayPosition(selectedGateways);
				if(selectedSwitches.length > 0)
					updateSwitchPosition(selectedSwitches);
				if(selectedWds.length > 0)
					updateWdsPosition(selectedWds);
				if(selectedLocatorDevices.length > 0)
					updateLocatorDevicePosition(selectedLocatorDevices);
			}
			
			private function createLocalData():void{
				if(selectedFixtures.length > 0)
					localFixtureData = new ArrayCollection(clone(commissionedFixtureData.source));
				if(selectedGateways.length > 0)
					localGatewayData = new ArrayCollection(clone(commissionedGatewayData.source)) 
				if(selectedSwitches.length > 0)
					localSwitchData = new ArrayCollection(clone(switchesData.source)) 
				if(selectedWds.length > 0)
					localWdsData = new ArrayCollection(clone(wdsData.source))
				if(selectedLocatorDevices.length > 0)
					localLocatorDeviceData = new ArrayCollection(clone(locatorDeviceData.source))
			}
			
			private function onDragExit(event:DragEvent) : void
			{
				event.preventDefault();
				event.currentTarget.hideDropFeedback(event);
			}
			
			private function roundValue( roundTo:Number, value:int ) : Number
			{
				return (Math.round(value/roundTo) * roundTo);
			}
			
			private function updateFixturePosition(updatedFixtures:ArrayCollection) : void 
			{
				var fixtureRequestXML:XML = <fixtures></fixtures>;
				
				for each (var fixtureItem:Object in updatedFixtures)
				{
					var fixtureXmlList:XMLList = XMLList("<fixture><id>" + fixtureItem.id + "</id><name>" + fixtureItem.name + "</name><xaxis>" + fixtureItem.xaxis + "</xaxis><yaxis>" + fixtureItem.yaxis + "</yaxis></fixture>");
					fixtureRequestXML.appendChild(fixtureXmlList);
				}
				
				updateFixturePositionHttpService.url = Constants.serverurl + "fixture/du/updateposition" + "/?ts=" + new Date().time;
				updateFixturePositionHttpService.request = fixtureRequestXML;
				updateFixturePositionHttpService.send();
			}
			
			private function updateGatewayPosition(updatedGateways:ArrayCollection) : void
			{
				var gatewayRequestXML:XML = <gateways></gateways>;
				
				for each (var gatewayItem:Object in updatedGateways)
				{
					var gatewayXmlList:XMLList = XMLList("<gateway><id>" + gatewayItem.id + "</id><xaxis>" + gatewayItem.xaxis + "</xaxis><yaxis>" + gatewayItem.yaxis + "</yaxis></gateway>");
					gatewayRequestXML.appendChild(gatewayXmlList);
				}
				
				updateGatewayPositionHttpService.url = Constants.serverurl + "gateway/du/updateposition" + "/?ts=" + new Date().time;
				updateGatewayPositionHttpService.request = gatewayRequestXML;
				updateGatewayPositionHttpService.send();
			}
			
			private function updateSwitchPosition(updatedSwitches:ArrayCollection) : void
			{
				var switchRequestXML:XML = <switches></switches>;
				
				for each (var switchItem:Object in updatedSwitches)
				{
					var switchXmlList:XMLList = XMLList("<switch><id>" + switchItem.id + "</id><xaxis>" + switchItem.xaxis + "</xaxis><yaxis>" + switchItem.yaxis + "</yaxis></switch>");
					switchRequestXML.appendChild(switchXmlList);
				}
				
				updateSwitchPositionHttpService.url = Constants.serverurl + "switch/du/updateposition" + "/?ts=" + new Date().time;
				updateSwitchPositionHttpService.request = switchRequestXML;
				updateSwitchPositionHttpService.send();
			}
			
			private function updateWdsPosition(updatedWds:ArrayCollection) : void
			{
				var wdsRequestXML:XML = <wdss></wdss>;
				
				for each (var wdsItem:Object in updatedWds)
				{
					var wdsXmlList:XMLList = XMLList("<wds><id>" + wdsItem.id + "</id><xaxis>" + wdsItem.xaxis + "</xaxis><yaxis>" + wdsItem.yaxis + "</yaxis></wds>");
					wdsRequestXML.appendChild(wdsXmlList);
				}
				
				updateWdsPositionHttpService.url = Constants.serverurl + "wds/du/updateposition" + "/?ts=" + new Date().time;
				updateWdsPositionHttpService.request = wdsRequestXML;
				updateWdsPositionHttpService.send();
			}
			
			private function updateLocatorDevicePosition(updatedLocatorDevices:ArrayCollection) : void
			{
				var locatorDeviceRequestXML:XML = <locatorDevices></locatorDevices>;
				
				for each (var locatorDeviceItem:Object in updatedLocatorDevices)
				{
					var locatorDeviceXmlList:XMLList = XMLList("<locatorDevice><id>" + locatorDeviceItem.id + "</id><xaxis>" + locatorDeviceItem.xaxis + "</xaxis><yaxis>" + locatorDeviceItem.yaxis + "</yaxis></locatorDevice>");
					locatorDeviceRequestXML.appendChild(locatorDeviceXmlList);
				}
				
				updateLocatorDevicePositionHttpService.url = Constants.serverurl + "locatordevice/du/updateposition" + "/?ts=" + new Date().time;
				updateLocatorDevicePositionHttpService.request = locatorDeviceRequestXML;
				updateLocatorDevicePositionHttpService.send();
			}

			public function handleChange(event:*):void 
			{
				panCanvas.removeEventListener(MouseEvent.MOUSE_UP, handleChange);
				
				if(selectedItems.length > 0)
					removeSelection();
				
				if(!event)
					return;
				
				if((event.currentTarget is PlotChart && event.currentTarget.selectedChartItem) || event.currentTarget is PanComponent)
				{
					var series:Array = floorPlanChart.series;
					for (var i:int=0; i<series.length; i++) 
					{
						var seriesItems:Array = series[i].selectedItems;
						for(var j:int=0; j<seriesItems.length; j++)
						{
							seriesItems[j].itemRenderer.filters = [glowFilter];
							selectedItems.push(seriesItems[j]);
							
							if(seriesItems[j].itemRenderer.name == Constants.FIXTURE_RENDERER)
							{
								selectedFixtures.addItem(seriesItems[j]);
								reportsTableList.selectFixture(seriesItems[j].item.id);
							}
							else if(seriesItems[j].itemRenderer.name == Constants.GATEWAY_RENDERER)
							{
								selectedGateways.addItem(seriesItems[j]);
								reportsTableList.selectGateway(seriesItems[j].item.id);
							}
							else if(seriesItems[j].itemRenderer.name == Constants.SWITCH_RENDERER)
							{
								selectedSwitches.addItem(seriesItems[j]);
							} 
							else if(seriesItems[j].itemRenderer.name == Constants.WDS_RENDERER)
							{
								selectedWds.addItem(seriesItems[j]);
							}
							else if(seriesItems[j].itemRenderer.name == Constants.LOCATOR_DEVICE_RENDERER)
							{
								selectedLocatorDevices.addItem(seriesItems[j]);
							}
						}
					}
				}
				/* else if(event.currentTarget is FixturesDock)
				{
				if(!event.searchObject)
				return;
				
				selectedItems = new Array(event.searchObject);
				var name:String = event.searchObject.name;
				
				applyFilters(name, "glowFilter");
				
				panTo(event.searchObject.xaxis, event.searchObject.yaxis);
				} */
				
				manageFloorPlanContextMenu();
			}
			
			private function manageFloorPlanContextMenu() : void
			{
				if(m_userRole == Constants.EMPLOYEE)
				{
					floorPlanContextMenu.customItems[0].visible = true;
					floorPlanContextMenu.customItems[0].enabled = (selectedFixtures.length > 0) ? true : false;
					
				}else
				{
					if(!floorPlanContextMenu || m_propertyMode == Constants.REPORT || m_propertyMode == Constants.COMMISSION) 
					{
						return;
					}
					if(m_enableMotionBits == "true" && m_userRole && m_userRole == Constants.ADMIN)
					{
						floorPlanContextMenu.customItems[5].visible = true;
					}
					else
					{
						floorPlanContextMenu.customItems[5].visible = false;
					}
					
					if(m_propertyType == Constants.FLOOR)
					{
						floorPlanContextMenu.customItems[0].visible = true;
						floorPlanContextMenu.customItems[1].visible = true;
						floorPlanContextMenu.customItems[2].visible = true;
						floorPlanContextMenu.customItems[3].visible = false;
						floorPlanContextMenu.customItems[4].visible = false;
						floorPlanContextMenu.customItems[6].visible = false;
						floorPlanContextMenu.customItems[9].visible = true;
						
						floorPlanContextMenu.customItems[0].enabled = (selectedFixtures.length > 0) ? true : false;
						floorPlanContextMenu.customItems[1].enabled = (selectedFixtures.length > 0) ? true : false;
						floorPlanContextMenu.customItems[2].enabled = (selectedFixtures.length > 0) ? true : false;
						floorPlanContextMenu.customItems[3].enabled = (selectedFixtures.length > 0) ? true : false;
						floorPlanContextMenu.customItems[4].enabled = (selectedFixtures.length > 0) ? true : false;
						floorPlanContextMenu.customItems[5].enabled = (selectedFixtures.length > 0) ? true : false;
						floorPlanContextMenu.customItems[6].enabled = (selectedFixtures.length > 0) ? true : false;
						floorPlanContextMenu.customItems[7].enabled = (selectedSwitches.length == 1) ? true : false;
						//floorPlanContextMenu.customItems[9].enabled = (selectedFixtures.length == 0 && selectedGateways.length == 0 && selectedSwitches.length == 0 && selectedWds.length == 0 && selectedLocatorDevices.length == 0) ? true : false;
						floorPlanContextMenu.customItems[9].enabled = (selectedItems.length == 0) ? true : false;
					}
					else if(m_propertyType == Constants.AREA)
					{
						floorPlanContextMenu.customItems[0].visible = false;
						floorPlanContextMenu.customItems[1].visible = false;
						floorPlanContextMenu.customItems[2].visible = false;
						floorPlanContextMenu.customItems[3].visible = false;
						floorPlanContextMenu.customItems[4].visible = false;
						floorPlanContextMenu.customItems[6].visible = false;
						floorPlanContextMenu.customItems[9].visible = false;
						
						floorPlanContextMenu.customItems[4].enabled = (selectedFixtures.length > 0) ? true : false;
						floorPlanContextMenu.customItems[5].enabled = (selectedFixtures.length > 0) ? true : false;
						floorPlanContextMenu.customItems[7].enabled = (selectedSwitches.length == 1) ? true : false;
					}
					floorPlanContextMenu.customItems[8].visible = false;
					if((m_propertyMode == Constants.SWITCH_MODE || m_propertyMode == Constants.GROUP_MODE || m_propertyMode == Constants.MOTION_BITS_GROUP_MODE) && widgetSelectedTab == Constants.LOCATION_TAB)
					{
						floorPlanContextMenu.customItems[8].visible = true;
						hideAllMenuItemExceptSetSwitch();
					}
					else if(m_propertyMode == Constants.SWITCH_MODE && widgetSelectedTab != Constants.LOCATION_TAB)
					{
						hideAllMenuItemExceptSetSwitch();
					}
					// Define Group, Define Switch, Unassign Groups and define motion bits are not supported from the floorplan.
					floorPlanContextMenu.customItems[3].visible = false;
					floorPlanContextMenu.customItems[4].visible = false;
					floorPlanContextMenu.customItems[5].visible = false;
					floorPlanContextMenu.customItems[6].visible = false;
				}
			}
			
			private function hideAllMenuItemExceptSetSwitch() : void
			{
				floorPlanContextMenu.customItems[0].visible = false;
				floorPlanContextMenu.customItems[1].visible = false;
				floorPlanContextMenu.customItems[2].visible = false;
				floorPlanContextMenu.customItems[3].visible = false;
				floorPlanContextMenu.customItems[4].visible = false;
				floorPlanContextMenu.customItems[5].visible = false;
				floorPlanContextMenu.customItems[6].visible = false;
				floorPlanContextMenu.customItems[7].visible = false;
				floorPlanContextMenu.customItems[9].visible = false;
			}
			private function manageDeviceContextMenu() : void
			{
				if(!floorPlanContextMenu || m_propertyMode == Constants.REPORT || m_propertyMode == Constants.COMMISSION || m_userRole==Constants.EMPLOYEE )
					return;
				floorPlanContextMenu.customItems[0].enabled = (mouseOverFixture) ? true : false;
				floorPlanContextMenu.customItems[1].enabled = (mouseOverFixture) ? true : false;
				floorPlanContextMenu.customItems[2].enabled = (mouseOverFixture) ? true : false;
				floorPlanContextMenu.customItems[3].enabled = (mouseOverFixture) ? true : false;
				floorPlanContextMenu.customItems[4].enabled = (mouseOverFixture) ? true : false;
				floorPlanContextMenu.customItems[5].enabled = (mouseOverFixture) ? true : false;
				floorPlanContextMenu.customItems[6].enabled = (mouseOverFixture) ? true : false;
				floorPlanContextMenu.customItems[7].enabled = (mouseOverSwitch && selectedSwitches.length == 1) ? true : false;
				floorPlanContextMenu.customItems[9].enabled = false;
			}
			
			private function panTo(xValue:int, yValue:int) : void
			{
				panCanvas.horizontalScrollPosition = (xValue - 8) * (floorPlanChart.scaleX);
				panCanvas.verticalScrollPosition = (floorPlanChart.height - yValue - 12) * (floorPlanChart.scaleY);
			}
			
			public function removeSelection(bClearReportTableList:Boolean = true) : void
			{
				var arrayLength:int = selectedItems.length;
				
				for (var j:int=0; j<arrayLength; j++)
				{
					if(selectedItems[0] is PlotSeriesItem)
					{
						var seriesItem:PlotSeriesItem = selectedItems[0];
						seriesItem.itemRenderer.filters = [];
						selectedItems.splice(0,1);
					}
					else
					{
						applyFilters(selectedItems[0], ""); // Only one item in selectedItems at this time. So removing the selection for the item at index 0.
						selectedItems.splice(0,1);
					}
				}
				if(bClearReportTableList)
					reportsTableList.removeSelection();
				resetData();
			}
			
			private function applyFilters( obj:Object, glowType:String) : void
			{
				if(obj.type == Constants.FIXTURE)
				{
					for(var i:int = 0; i<fixturePlotSeries.items.length; i++)
					{
						if(obj.id == fixturePlotSeries.items[i].item.id)
						{
							if(glowType == "glowFilter")
								fixturePlotSeries.getChildAt(i).filters = [glowFilter];
							else if(glowType == "")
								fixturePlotSeries.getChildAt(i).filters = [];
							break;
						}
					}
				}
				else if(obj.type == Constants.GATEWAY)
				{
					for(var j:int = 0; j<gatewayPlotSeries.items.length; j++)
					{
						if(obj.id == gatewayPlotSeries.items[j].item.id)
						{
							if(glowType == "glowFilter")
								gatewayPlotSeries.getChildAt(j).filters = [glowFilter];
							else if(glowType == "")
								gatewayPlotSeries.getChildAt(j).filters = [];
							break;
						}
					}
					
					// DO NOT DELETE THIS PIECE OF CODE
					// TODO - Gateway object has incomplete data at this time. Waiting for the service to be fixed.
					/* for(var k:int = 0; k<fixturePlotSeries.dataProvider.length; k++)
					{
					if(obj.name == Object(fixturePlotSeries.getChildAt(k)).data.item.gateway.name)
					{
					if(glowType == "glowFilter")
					fixturePlotSeries.getChildAt(k).filters = [glowFilter];
					else if(glowType == "")
					fixturePlotSeries.getChildAt(k).filters = [];
					break;
					}
					} */
				}
				else if(obj.type == Constants.SWITCH)
				{
					for(var m:int = 0; m<switchPlotSeries.items.length; m++)
					{
						if(obj.id == switchPlotSeries.items[m].item.id)
						{
							if(glowType == "glowFilter")
								switchPlotSeries.getChildAt(m).filters = [glowFilter];
							else if(glowType == "")
								switchPlotSeries.getChildAt(m).filters = [];
							break;
						}
					}
				}
				else if(obj.type == Constants.WDS)
				{
					for(var n:int = 0; n<wdsPlotSeries.items.length; n++)
					{
						if(obj.id == wdsPlotSeries.items[n].item.id)
						{
							if(glowType == "glowFilter")
								wdsPlotSeries.getChildAt(n).filters = [glowFilter];
							else if(glowType == "")
								wdsPlotSeries.getChildAt(n).filters = [];
							break;
						}
					}
				}
				else if(obj.type == Constants.LOCATORDEVICE)
				{
					for(var p:int = 0; p<locatorDevicePlotSeries.items.length; p++)
					{
						if(obj.id == locatorDevicePlotSeries.items[p].item.id)
						{
							if(glowType == "glowFilter")
								locatorDevicePlotSeries.getChildAt(p).filters = [glowFilter];
							else if(glowType == "")
								locatorDevicePlotSeries.getChildAt(p).filters = [];
							break;
						}
					}
				}
				
			}
			
			private function pinOrUnpin(event:MouseEvent) : void
			{
				if(event.currentTarget.toolTip == Constants.UNPIN_TOOLS_WINDOW)
				{
					pinToolsWindow = false;
					pinOrUnpinImage.source = Images.LeftArrow;
					pinOrUnpinImage.toolTip = Constants.PIN_TOOLS_WINDOW;
				}
				else if(event.currentTarget.toolTip == Constants.PIN_TOOLS_WINDOW)
				{
					pinToolsWindow = true;
					pinOrUnpinImage.source = Images.RightArrow;
					pinOrUnpinImage.toolTip = Constants.UNPIN_TOOLS_WINDOW;
				}
			}
			
			private function onLockDragDropChange( event:Event ) : void
			{
				event.currentTarget.selected ? removeListeners() : addListeners();
			}
			
			private function selectUnselectSnapToGrid( event:Event ) : void
			{
				event.currentTarget.selected ? showGridLines() : hideGridLines();
			}
			
			private function showGridLines() : void
			{
				gridDirection="both";
				if(!lockDragDrop.selected)
					snapToGrid.enabled = true;
				gridPixelsSlider.enabled = true;
			}
			
			private function hideGridLines() : void
			{
				gridDirection="none";
				snapToGrid.enabled = false;
				gridPixelsSlider.enabled = false;
			}
			
			private function snapToGridDevices() : void
			{
				dropDevice(true, 0, 0);
			}
			
			private function dimFixtureResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				if(m_propertyMode == Constants.SWITCH_MODE)
				{
					if (sceneDropDown.selectedIndex != -1) {
						saveSceneLightLevelBySwitchIdHttpService.url = Constants.serverurl + "scene/updatescenelevel?ts=" + new Date().time;
						saveSceneLightLevelBySwitchIdHttpService.request = getSceneLightLevelFixtureToUpdate(reportsTableList.sceneTableGrid.selectedItems);
						saveSceneLightLevelBySwitchIdHttpService.send();
					}
				}
			}
			
			private function dimFixtureFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Dimming command failed. Please retry.", true);
			}
			
			private function fixtureModeResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function fixtureModeFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Auto command failed. Please retry.", true);
			}
			
			private function realTimeResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				fixtureHttpService.url = Constants.serverurl + "fixture/list/" + m_propertyType + "/" + m_propertyId + "/?ts=" + new Date().time;
				fixtureHttpService.send();
			}
			
			private function realTimeFailure(event:FaultEvent):void
			{				
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Realtime command failed. Please retry.", true);
			}
			
			private function fixturePositionUpdateResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				commissionedFixtureData.refresh();
			}
			
			private function fixturePositionUpdateFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Fixture update command failed. Please retry.", true);
			}
			
			private function gatewayPositionUpdateResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				commissionedGatewayData.refresh();
			}
			
			private function gatewayPositionUpdateFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Gateway update command failed. Please retry.", true);
			}
			
			private function switchPositionUpdateResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				switchesData.refresh();
			}
			
			private function switchPositionUpdateFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Switch update command failed. Please retry.", true);
			}
			
			private function locatorDevicePositionUpdateResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				locatorDeviceData.refresh();
			}
			
			private function locatorDevicePositionUpdateFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Locator Device update command failed. Please retry.", true);
			}

			private function wdsPositionUpdateResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				wdsData.refresh();
			}
			
			private function wdsPositionUpdateFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Wds update command failed. Please retry.", true);
			}

			
			private function fixtureRealTimeResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				if(!mouseOverFixture)
					return;
				
				if (fixtureDetailsTimer != null) 
				{
					fixtureDetailsTimer.stop();
					fixtureDetailsTimer = null;
				}
				
				fixtureDetailsTimer = new Timer(1000, 5);
				fixtureDetailsTimer.addEventListener(TimerEvent.TIMER, fixtureDetailsTimerHandler);
				fixtureDetailsTimer.start();
			}
			
			private function fixtureRealTimeFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Realtime command failed. Please retry.", true);
			}
			
			private function getFixtureByIdResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				if(!mouseOverFixture)
					return;
				
				if(event.result == "")
					return;
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				var serverTime:Date;
				var lastConnectivityTime:Date;
				
				if(mouseOverFixture.lastconnectivityat != resultObj.fixture.lastconnectivityat)
				{
					if(fixtureDetailsTimer)
					{
						fixtureDetailsTimer.stop();
						fixtureDetailsTimer = null;
					}
					
					serverTime = getServerTime();
					serverTime.setMinutes(serverTime.getMinutes() - 15);
					
					lastConnectivityTime = createDate(resultObj.fixture.lastconnectivityat);
					
					if(lastConnectivityTime <= serverTime)
					{
						toolTipColor = "0xFDCCBB";
					}
					else if(lastConnectivityTime > serverTime)
					{
						toolTipColor = "0x9FF97B"; // Green
					}
					
					// NOTE: DO NOT DELETE THIS CODE. MIGHT BE USEFUL WHEN REAL TIME FIRED FOR MULTIPLE FIXTURES
					/* for(var i:int=0 ; i<commissionedFixtureData.length;  i++)
					{
					if(resultObj.fixture.id == commissionedFixtureData[i].id)
					{
					commissionedFixtureData[i].name = resultObj.fixture.name;
					commissionedFixtureData[i].lightlevel = resultObj.fixture.lightlevel;
					commissionedFixtureData[i].wattage = resultObj.fixture.wattage;
					commissionedFixtureData[i].avgtemperature = resultObj.fixture.avgtemperature;
					commissionedFixtureData[i].ambientlight = resultObj.fixture.ambientlight;
					commissionedFixtureData[i].lastoccupancyseen = resultObj.fixture.lastoccupancyseen;
					commissionedFixtureData[i].currentprofile = resultObj.fixture.currentprofile;
					commissionedFixtureData[i].state = resultObj.fixture.state;
					commissionedFixtureData[i].lastconnectivityat = resultObj.fixture.lastconnectivityat;
					commissionedFixtureData[i].bulblife = resultObj.fixture.bulblife;
					}
					} */
					
					mouseOverFixture.name = resultObj.fixture.name;
					mouseOverFixture.lightlevel = resultObj.fixture.lightlevel;
					mouseOverFixture.wattage = resultObj.fixture.wattage;
					mouseOverFixture.avgtemperature = resultObj.fixture.avgtemperature;
					mouseOverFixture.ambientlight = resultObj.fixture.ambientlight;
					mouseOverFixture.lastoccupancyseen = resultObj.fixture.lastoccupancyseen;
					mouseOverFixture.currentprofile = resultObj.fixture.currentprofile;
					mouseOverFixture.state = resultObj.fixture.state;
					mouseOverFixture.lastconnectivityat = resultObj.fixture.lastconnectivityat;
					mouseOverFixture.bulblife = resultObj.fixture.bulblife;
					mouseOverFixture.currentstate = resultObj.fixture.currentstate;
					
					var profileObj:Object = getProfileDataById(resultObj.fixture.groupid);
					//If default profile is there, then rename the default profiles with suffix "_default"
					if(profileObj!=null && profileObj.defaultProfile==true && profileObj.profileNo>0)
					{
						mouseOverFixture.currentprofile = setDefaultProfileName(mouseOverFixture.currentprofile);
					}
					/*
					for(var i:int = 0; i<fixturePlotSeries.dataProvider.length; i++)
					{
						if(resultObj.fixture.id == fixturePlotSeries.items[i].item.id)
						{
							fixturePlotSeries.items[i].itemRenderer.onUpdateComplete();
						}
					}
					*/
					commissionedFixtureData.dispatchEvent(new CollectionEvent(CollectionEvent.COLLECTION_CHANGE));
					
					if(dataTipRenderer)
					{
						dataTipRenderer.setBackgroundColor(toolTipColor);
						buildDataTip(mouseOverFixture);
						dataTipRenderer.updateData();
					}
				}
				
				if(fixtureDetailsTimer && fixtureDetailsTimer.currentCount == 5)
				{
					
					fixtureDetailsTimer.stop();
					fixtureDetailsTimer = null;
					
					serverTime = getServerTime();
					serverTime.setMinutes(serverTime.getMinutes() - 15);
					
					lastConnectivityTime = createDate(resultObj.fixture.lastconnectivityat);
					
					if(lastConnectivityTime <= serverTime)
					{
						toolTipColor = "0xFDCCBB";
					}
					else if(lastConnectivityTime > serverTime)
					{
						toolTipColor = "0xF8FBA9";
					}
					
					if(dataTipRenderer)
					{
						dataTipRenderer.setBackgroundColor(toolTipColor);
						buildDataTip(mouseOverFixture);
						dataTipRenderer.updateData();
					}
					return;
				}
				
				// NOTE: DO NOT DELETE/ UNCOMMENT THE COMMENTED CODE. 
				/* if(mouseOverFixture.lastconnectivityat == resultObj.fixture.lastconnectivityat)
				{
				if(realTimeCounter < 5)
				{
				var d:Date = new Date();
				getFixtureByIdHttpService.url= Constants.serverurl + "fixture/details/" + mouseOverFixture.id + "/?i=" + d.time;
				getFixtureByIdHttpService.send();
				}
				else
				{
				date = new Date();
				date.setMinutes(date.getMinutes() - 15);
				
				serverDate = createDate(resultObj.fixture.lastconnectivityat);
				
				if(serverDate <= date)
				{
				toolTipColor = "0xFDCCBB";
				showFullDeatils = false;
				styleManager.getStyleDeclaration("mx.charts.chartClasses.DataTip").setStyle("backgroundColor", 0xFDCCBB); // Red
				}
				else if(serverDate > date)
				{
				toolTipColor = "0xF8FBA9";
				showFullDeatils = true;
				styleManager.getStyleDeclaration("mx.charts.chartClasses.DataTip").setStyle("backgroundColor", 0xF8FBA9); // Yellow
				}
				
				realTimeCounter = 1;
				floorPlanChart.showDataTips = false;
				floorPlanChart.dataTipFunction = showDataTip;
				floorPlanChart.showDataTips = true; 
				return;
				}
				}
				else if(mouseOverFixture.lastconnectivityat != resultObj.fixture.lastconnectivityat)
				{
				date = new Date();
				date.setMinutes(date.getMinutes() - 15);
				
				serverDate = createDate(resultObj.fixture.lastconnectivityat);
				
				if(serverDate <= date)
				{
				toolTipColor = "0xFDCCBB";
				showFullDeatils = false;
				styleManager.getStyleDeclaration("mx.charts.chartClasses.DataTip").setStyle("backgroundColor", 0xFDCCBB); // Red
				}
				else if(serverDate > date)
				{
				toolTipColor = "0x9FF97B";
				showFullDeatils = true;
				styleManager.getStyleDeclaration("mx.charts.chartClasses.DataTip").setStyle("backgroundColor", 0x9FF97B); // Green
				}
				
				for(var i:int=0 ; i<commissionedFixtureData.length;  i++)
				{
				if(resultObj.fixture.id == commissionedFixtureData[i].id)
				{
				commissionedFixtureData[i].name = resultObj.fixture.name;
				commissionedFixtureData[i].lightlevel = resultObj.fixture.lightlevel;
				commissionedFixtureData[i].wattage = resultObj.fixture.wattage;
				commissionedFixtureData[i].avgtemperature = resultObj.fixture.avgtemperature;
				commissionedFixtureData[i].ambientlight = resultObj.fixture.ambientlight;
				commissionedFixtureData[i].lastoccupancyseen = resultObj.fixture.lastoccupancyseen;
				commissionedFixtureData[i].currentprofile = resultObj.fixture.currentprofile;
				commissionedFixtureData[i].state = resultObj.fixture.state;
				commissionedFixtureData[i].lastconnectivityat = resultObj.fixture.lastconnectivityat;
				commissionedFixtureData[i].bulblife = resultObj.fixture.bulblife;
				}
				}
				
				commissionedFixtureData.dispatchEvent(new CollectionEvent(CollectionEvent.COLLECTION_CHANGE));
				
				floorPlanChart.showDataTips = false;
				floorPlanChart.dataTipFunction = showDataTip;
				floorPlanChart.showDataTips = true;
				}
				
				realTimeCounter++; */
			} 
			
			private function getFixtureByIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Get fixture realtime command failed. Please retry.", true);
			}
			
			private function fixtureDetailsTimerHandler(event:TimerEvent) : void
			{
				if(!mouseOverFixture)
				{
					fixtureDetailsTimer.stop();
					fixtureDetailsTimer = null;
					return;
				}
				
				getFixtureByIdHttpService.url= Constants.serverurl + "fixture/details/" + mouseOverFixture.id + "/?ts=" + new Date().time;
				getFixtureByIdHttpService.send();
			}
			
			private function gatewayRealTimeResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				if(!mouseOverGateway)
					return;
				
				if (gatewayDetailsTimer != null) 
				{
					gatewayDetailsTimer.stop();
					gatewayDetailsTimer = null;
				}
				
				gatewayDetailsTimer = new Timer(1000, 5);
				gatewayDetailsTimer.addEventListener(TimerEvent.TIMER, gatewayDetailsTimerHandler);
				gatewayDetailsTimer.start();
			}
			
			private function gatewayRealTimeFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Realtime command failed. Please retry.", true);
			}
			
			private function getGatewayByIdResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				if(!mouseOverGateway)
					return;
				
				if(event.result == "")
					return;
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				var serverTime:Date;
				var lastConnectivityTime:Date;
				
				if(mouseOverGateway.lastconnectivityat != resultObj.gateway.lastconnectivityat)
				{
					if(gatewayDetailsTimer)
					{
						gatewayDetailsTimer.stop();
						gatewayDetailsTimer = null;
					}
					
					serverTime = getServerTime();
					serverTime.setMinutes(serverTime.getMinutes() - 15);
					
					lastConnectivityTime = createDate(resultObj.gateway.lastconnectivityat);
					
					if(lastConnectivityTime <= serverTime)
					{
						toolTipColor = "0xFDCCBB";
					}
					else if(lastConnectivityTime > serverTime)
					{
						toolTipColor = "0x9FF97B"; // Green
					}
					
					mouseOverGateway.lastconnectivityat = resultObj.gateway.lastconnectivityat;
					mouseOverGateway.commissioned = resultObj.gateway.commissioned;
					mouseOverGateway.name = resultObj.gateway.name;
					mouseOverGateway.noofsensors = resultObj.gateway.noofsensors;
					mouseOverGateway.noofactivesensors = resultObj.gateway.noofactivesensors;
					
					/*
					for(var i:int = 0; i<gatewayPlotSeries.dataProvider.length; i++)
					{
						if(resultObj.gateway.id == gatewayPlotSeries.items[i].item.id)
						{
							gatewayPlotSeries.items[i].itemRenderer.onUpdateComplete();
						}
					}
					*/
					
					commissionedGatewayData.dispatchEvent(new CollectionEvent(CollectionEvent.COLLECTION_CHANGE));
					
					if(dataTipRenderer)
					{
						dataTipRenderer.setBackgroundColor(toolTipColor);
						buildDataTip(mouseOverGateway);
						dataTipRenderer.updateData();
					}
				}
				
				if(gatewayDetailsTimer && gatewayDetailsTimer.currentCount == 5)
				{
					gatewayDetailsTimer.stop();
					gatewayDetailsTimer = null;
					
					serverTime = getServerTime();
					serverTime.setMinutes(serverTime.getMinutes() - 15);
					
					lastConnectivityTime = createDate(resultObj.gateway.lastconnectivityat);
					
					if(lastConnectivityTime <= serverTime)
					{
						toolTipColor = "0xFDCCBB";
					}
					else if(lastConnectivityTime > serverTime)
					{
						toolTipColor = "0xF8FBA9";
					}
					
					if(dataTipRenderer)
					{
						dataTipRenderer.setBackgroundColor(toolTipColor);
						buildDataTip(mouseOverGateway);
						dataTipRenderer.updateData();
					}
					return;
				}
			} 
			
			private function getGatewayByIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				else
					FlexGlobals.topLevelApplication.showAlertMarquee("Get gateway realtime command failed. Please retry.", true);
			}
			
			private function getGatewayDetailsResult(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				if(event.result == "")
					return;
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);				
				
				var oGateway:Object = resultObj.gateway;
				
				if (devicePosition.x > 0 && devicePosition.y > 0) 
				{
					oGateway.xaxis = devicePosition.x;
					oGateway.yaxis = devicePosition.y;
				} else { 
					oGateway.xaxis = int((panCanvas.horizontalScrollPosition) / (floorPlanChart.scaleX) + (12 * floorPlanChart.scaleX)) + 30;
					oGateway.yaxis = int(maxYaxis - (panCanvas.verticalScrollPosition) / (floorPlanChart.scaleY) - (12 * floorPlanChart.scaleY)) - 30;
				}
				
				resetDevicePosition();
				commissionedGatewayData.addItem(oGateway);
				
				if(oGateway)
				{
					FlexGlobals.topLevelApplication.showAlertMarquee("Positioning gateway " + oGateway.id + ", " + oGateway.xaxis + ", " + oGateway.yaxis, true);
					
					var gatewayXmlList:XML = XML("<gateways><gateway><id>" + oGateway.id + "</id><xaxis>" + oGateway.xaxis + "</xaxis><yaxis>" + oGateway.yaxis + "</yaxis></gateway></gateways>");
					
					updateGatewayPositionHttpService.url = Constants.serverurl + "gateway/du/updateposition" + "/?ts=" + new Date().time;
					updateGatewayPositionHttpService.request = gatewayXmlList;
					updateGatewayPositionHttpService.send();
				}
				
				commissionedGatewayData.refresh();
			} 
			
			private function getGatewayDetailsFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function gatewayDetailsTimerHandler(event:TimerEvent) : void
			{
				if(!mouseOverGateway)
				{
					gatewayDetailsTimer.stop();
					gatewayDetailsTimer = null;
					return;
				}
				
				getGatewayByIdHttpService.url= Constants.serverurl + "gateway/details/" + mouseOverGateway.id + "/?ts=" + new Date().time;
				getGatewayByIdHttpService.send();
			}
			
			private function onGetFixtureOutageList(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				fixtureData.removeAll();
				commissionedFixtureData.removeAll();
				
				if(event.result == "")
					return;
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				(resultObj.fixtureOutageVOes.fixture is ArrayCollection) ? (commissionedFixtureData = resultObj.fixtureOutageVOes.fixture) :  (commissionedFixtureData.addItem(resultObj.fixtureOutageVOes.fixture));
				
				reportsTableList.reportTableGrid.dataProvider = commissionedFixtureData;
				commissionedFixtureData.enableAutoUpdate();
			} 
			
			private function onGetFixtureOutageListFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onGetMotionGroupsList(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				motionGroupsList.removeAll();
				
				if(event.result == "")
				{
					floorPlanChart.contextMenu = floorPlanContextMenu;
					if(layersDropDown.selectedItem && layersDropDown.selectedItem.label == Constants.MOTION_GROUP)
					{
						createGroupsFilterData(Constants.MOTION_GROUP);
					}
					return;
				}
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				(resultObj.gemsGroups.gemsGroup is ArrayCollection) ? (motionGroupsList = resultObj.gemsGroups.gemsGroup) :  (motionGroupsList.addItem(resultObj.gemsGroups.gemsGroup));
				
				if(layersDropDown.selectedItem && layersDropDown.selectedItem.label == Constants.MOTION_GROUP)
				{
					createGroupsFilterData(Constants.MOTION_GROUP);
				}
			}
			
			private function onGetMotionGroupsListFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onGetSwitchGroupsList(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				switchGroupsList.removeAll();
				
				if(event.result == "")
				{
					floorPlanChart.contextMenu = floorPlanContextMenu;
					if(layersDropDown.selectedItem && layersDropDown.selectedItem.label == Constants.SWITCH_GROUP)
					{
						createGroupsFilterData(Constants.SWITCH_GROUP);
					}
					return;
				}
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				(resultObj.gemsGroups.gemsGroup is ArrayCollection) ? (switchGroupsList = resultObj.gemsGroups.gemsGroup) :  (switchGroupsList.addItem(resultObj.gemsGroups.gemsGroup));
				
				if(layersDropDown.selectedItem && layersDropDown.selectedItem.label == Constants.SWITCH_GROUP)
				{
					createGroupsFilterData(Constants.SWITCH_GROUP);
				}
			}
			
			private function onGetSwitchGroupsListFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onGetFixtuersByGroupId(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				fixturesByGroupList.removeAll();
				
				if(event.result == "")
				{
					commissionedFixtureData.filterFunction = filterFixturesByGroup;
					commissionedFixtureData.refresh();
					reportsTableList.groupFixtureData.removeAll();
					//fixturePlotSeries.invalidateDisplayList();
					return;
				}
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				var tempData:ArrayCollection = new ArrayCollection();
				(resultObj.gemsGroupFixtures.gemsGroupFixture is ArrayCollection) ? (tempData = resultObj.gemsGroupFixtures.gemsGroupFixture) :  (tempData.addItem(resultObj.gemsGroupFixtures.gemsGroupFixture));
				
				if(tempData!=null && tempData.length>0)
				{
					for each(var gemsGrpFixObj:Object in tempData)
					{
						fixturesByGroupList.addItem(gemsGrpFixObj.fixture);
						if(associatedGWId == -1)
							associatedGWId = gemsGrpFixObj.fixture.secgwid;
					}
				}
				if (fixturesByGroupList!=null && fixturesByGroupList.length>0)
				{
					if (m_propertyMode == Constants.GROUP_MODE || m_propertyMode == Constants.MOTION_BITS_GROUP_MODE) {
						reportsTableList.groupFixtureData = fixturesByGroupList;
					}
					else {
						commissionedFixtureData.filterFunction = filterFixturesByGroup;
						commissionedFixtureData.refresh();
					}
				}
				//fixturePlotSeries.invalidateDisplayList();
			}
			
			private function onGetFixtuersByGroupIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onGetFixtuersBySwitchId(event:ResultEvent):void{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				fixturesBySwitchList.removeAll();
				var tmpGwId:int = -1;
				bMultipleGWs = false;
				
				if(event.result == "")
				{
					reportsTableList.switchFixtureData.removeAll();
					reportsTableList.switchFixtureData.refresh();
					return;
				}
				try {
					var xml:XMLDocument = new XMLDocument(event.result.toString());				
					var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
					var resultObj:Object = decoder.decodeXML(xml);
					var tempData:ArrayCollection = new ArrayCollection();
					(resultObj.gemsGroupFixtures.gemsGroupFixture is ArrayCollection) ? (tempData = resultObj.gemsGroupFixtures.gemsGroupFixture) :  (tempData.addItem(resultObj.gemsGroupFixtures.gemsGroupFixture));
					if(tempData!=null && tempData.length>0)
					{
						for each(var gemsGrpFixObj:Object in tempData)
						{
							//Fill the gateway name in the ArrayCollection before assigning to UI
							if(gatewayData!=null && commissionedGatewayData.length>0)
							{
								for each(var gateway:Object in commissionedGatewayData)
								{
									if(gateway.id == gemsGrpFixObj.fixture.secgwid)
									{
										gemsGrpFixObj.fixture.gateway.name = gateway.name;
									}
								}
							}
							gemsGrpFixObj.fixture.needSync = gemsGrpFixObj.needSync;
							fixturesBySwitchList.addItem(gemsGrpFixObj.fixture);
							if(tmpGwId == -1)
								tmpGwId = gemsGrpFixObj.fixture.secgwid;
							
							if(tmpGwId != gemsGrpFixObj.fixture.secgwid)
								bMultipleGWs = true;
							
							
						}
						
						if(bMultipleGWs == false)
							associatedGWId = tmpGwId;
					}
					if(fixturesBySwitchList.length > 0 && m_propertyMode == Constants.SWITCH_MODE)
					{
						reportsTableList.switchFixtureData = fixturesBySwitchList;

						if(widgetSelectedTab == Constants.SCENE_TAB)
							commissionedFixtureData.filterFunction = filterFixturesBySwitch;
						else
							commissionedFixtureData.filterFunction = null;
						commissionedFixtureData.refresh();
					}
				}
				catch(e:Error) {
					trace(e.message);
				}
			}
			
			private function onGetFixtuersBySwitchIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function updateWdsSwAssociationDuringCommission() : void
			{
				var requestXML:XML = getSwitchWDSListToUpdate(wdssBySwitchList);
				var xmlList:XMLList = XMLList("<wds><id>" + tempWdsId + "</id></wds>");
				requestXML.appendChild(xmlList);
				
				// Call service to update the associated WDS list
				updateSwitchWDSsBySwitchIdHttpService.url = Constants.serverurl + "wds/updateSwitchWds/" + tempSwitchId + "?ts=" + new Date().time;
				updateSwitchWDSsBySwitchIdHttpService.request = requestXML;
				updateSwitchWDSsBySwitchIdHttpService.send();
				
				tempSwitchId = "";
				tempWdsId = "";
				
				return;
			}
			
			private function onGetWDSsBySwitchId(event:ResultEvent):void{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				wdssBySwitchList.removeAll();
				bWDSAssociated = false;
				wdsGwId = -1;
				if(event.result == "")
				{
					if(m_propertyMode == Constants.COMMISSION && tempSwitchId != "")
					{
						// When the WDS is being added from switch widget then switchID is not null. Here get the list of already associated
						// with the switch and then add this wds to the switch
						updateWdsSwAssociationDuringCommission();
					}
					return;
				}
				try 
				{
					var xml:XMLDocument = new XMLDocument(event.result.toString());				
					var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
					var resultObj:Object = decoder.decodeXML(xml);
					var tempData:ArrayCollection = new ArrayCollection();
					(resultObj.wdss.wds is ArrayCollection) ? (tempData = resultObj.wdss.wds) :  (tempData.addItem(resultObj.wdss.wds));
					
					if(tempData!=null && tempData.length>0)
					{
						for each(var wds:Object in tempData)
						{
							wdssBySwitchList.addItem(wds);
							if(bWDSAssociated == false)
							{
								bWDSAssociated = true;
								wdsGwId = wds.gatewayid;
							}
						}
					}
					if(wdssBySwitchList.length>0 && m_propertyMode == Constants.SWITCH_MODE)
						reportsTableList.wdsData = wdssBySwitchList;
					
					if(m_propertyMode == Constants.COMMISSION && tempSwitchId != "")
					{
						if(bWDSAssociated && wdsGwId !=  parseInt(tempGwId))
						{
							Alert.show("Failed to associate the EWS as another EWS bound to a different gateway is already associated", "Alert");
							tempSwitchId = "";
							tempWdsId = "";
							tempGwId = "";
							return;
						}
						// When the WDS is being added from switch widget then switchID is not null. Here get the list of already associated
						// with the switch and then add this wds to the switch
						updateWdsSwAssociationDuringCommission();
					}
				}catch(e:Error) {
					trace(e.message);
				}
			}
			
			private function onGetWDSsBySwitchIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}

			private function onUpdateFixtuersBySwitchId(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);

				if(resultObj.response.msg != null && resultObj.response.msg != "")
					Alert.show("Failed to associate fixture(s): " + resultObj.response.msg + " with the group as it/they are already associated with 10 groups", "Alert");

				//Reload Fixure by Switch ID
				getFixturesBySwitchIdHttpService.url = Constants.serverurl + "switch/getSwitchFixtures/" + m_switchId + "?ts=" + new Date().time;
				getFixturesBySwitchIdHttpService.send();
			}
			private function onUpdateFixtuersBySwitchIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onUpdateFixtuersByMGId(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				if(m_propertyMode == Constants.GROUP_MODE && resultObj.response.msg != null && resultObj.response.msg != "")
					Alert.show("Failed to associate fixture(s): " + resultObj.response.msg + " with the group as it/they are already associated with 10 groups", "Alert");

				//Reload Fixure by Group ID
				fixturesByGroupIdHttpService.url = Constants.serverurl + "gemsgroupfixture/list/" + m_groupId + "/?ts=" + new Date().time;;;
				fixturesByGroupIdHttpService.send();
			}
			private function onUpdateFixtuersByMGIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}

			private function onUpdateWDSsBySwitchId(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				//Reload WDS by Switch ID
				getWDSsBySwitchIdHttpService.url = Constants.serverurl + "wds/list/switch/" + m_switchId + "?ts=" + new Date().time;
				getWDSsBySwitchIdHttpService.send();
			}
			private function onUpdateWDSsBySwitchIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onGetSceneBySwitchId(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				sceneDropDownArray.removeAll();
				if(event.result == "")
				{
					return;
				}
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				var tempData:ArrayCollection = new ArrayCollection();
				(resultObj.scenes.scene is ArrayCollection) ? (tempData = resultObj.scenes.scene) :  (tempData.addItem(resultObj.scenes.scene));
				
				for each(var sceneObj:Object in tempData)
				{
					if(Number(sceneObj.sceneOrder)>1)
						sceneDropDownArray.addItem(sceneObj);
				}
				sceneDropDownArray.refresh();
				
				if (sceneDropDownArray.length > 0)
				{
					if(nSceneIndex != -1)
					{
						sceneDropDown.selectedIndex = nSceneIndex;
						nSceneIndex = -1;
					}
					else
						sceneDropDown.selectedIndex = 0;
					deleteScene.enabled = true;
					editScene.enabled = true;
					applyScene.enabled = true;
				}
				else
				{
					deleteScene.enabled = false;
					editScene.enabled = false;
					applyScene.enabled = false;
					sceneId.text = "";
				}
			}
			private function onGetSceneBySwitchIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
			}
			
			private function onAddSceneBySwitchId(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				if(resultObj!=null) {
					if(m_bCreateScene)
						sceneDropDownArray.addItem(resultObj.scene);
					else
						sceneDropDownArray.setItemAt(resultObj.scene, sceneDropDown.selectedIndex);
				}
				sceneDropDownArray.refresh();
				sceneDropDown.selectedItem = resultObj.scene;
				
				if(deleteScene.enabled == false)
				{
					deleteScene.enabled = true;
					editScene.enabled = true;
					applyScene.enabled = true;
				}
//				getSceneBySwitchIdHttpService.url = Constants.serverurl + "scene/list/sid/" + m_switchId + "?ts=" + new Date().time;
//				getSceneBySwitchIdHttpService.send();
			}
			private function onAddSceneBySwitchIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onDeleteSceneBySwitchId(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				//Reload the Scene DropDown
				getSceneBySwitchIdHttpService.url = Constants.serverurl + "scene/list/sid/" + m_switchId + "?ts=" + new Date().time;
				getSceneBySwitchIdHttpService.send();
			}
			
			private function onDeleteSceneBySwitchIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onGetSceneLevelBySwitchId(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				if(!resultObj)
					return;
				
				var tempData:ArrayCollection = new ArrayCollection();
				(resultObj.sceneLevels.sceneLevel is ArrayCollection) ? (tempData = resultObj.sceneLevels.sceneLevel) :  (tempData.addItem(resultObj.sceneLevels.sceneLevel));
				
				if(tempData!=null && tempData.length>0)
				{
					for each(var sceneLevelObj:Object in tempData)
					{
						for each(var fixObj:Object in fixturesBySwitchList)
						{
							if(fixObj.id==sceneLevelObj.fixtureid)
							{
								fixObj.lightlevel = sceneLevelObj.lightlevel;
								break;
							}
						}
					}
				}
				
			}
			
			private function onGetSceneLevelBySwitchIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
		
			private function onSaveSceneLightLevelBySwitchId(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				//Reload Fixure by selected scene ID
				if(sceneDropDown) {
					var currentSceneObj:Object   = sceneDropDown.selectedItem;
					if(currentSceneObj)
					{
						getSceneLevelBySwitchIdHttpService.url = Constants.serverurl + "scene/list/scenelevel/sid/"+currentSceneObj.id+"?ts=" + new Date().time;
						getSceneLevelBySwitchIdHttpService.send();

						if(bSceneTestInProgress)
						{
							applySceneBySwitchIdHttpService.url = Constants.serverurl + "switch/op/dim/switch/" + m_switchId + "/scene/" + currentSceneObj.id + "/102/10?ts=" + new Date().time;
							applySceneBySwitchIdHttpService.send();
						}
					}
				}
			}
			
			private function onSaveSceneLightLevelBySwitchIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onApplySceneBySwitchId(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				//Reload Fixure by selected scene ID
				if(sceneDropDown) {
					var currentSceneObj:Object   = sceneDropDown.selectedItem;
					if(currentSceneObj)
					{
						getSceneLevelBySwitchIdHttpService.url = Constants.serverurl + "scene/list/scenelevel/sid/"+currentSceneObj.id+"?ts=" + new Date().time;
						getSceneLevelBySwitchIdHttpService.send();
					}
				}
			}
			
			private function onApplySceneBySwitchIdFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onSaveSceneList(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
		
				getSceneBySwitchIdHttpService.url = Constants.serverurl + "scene/list/sid/" + m_switchId + "?ts=" + new Date().time;
				getSceneBySwitchIdHttpService.send();
			}
			
			private function onSaveSceneListFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			
			private function onGetImageUpgradeJobStatus(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				if(!resultObj)
					return;
				if(resultObj.response.status==0)
				{
					showToolbarViewStack=true;
					toolbarViewStack.selectedIndex=3;
					
					//If Mode is Image Upgrade then start the Auto Timer to refresh the Image Upgrade device status
					autoRefreshTimer.addEventListener(TimerEvent.TIMER, onAutoRefreshTimerComplete);
					autoRefreshTimer.start();
					
					//Get the Image upgrade device status
					var txnObj:Object = new Object();
					txnObj.transactionId = TXN_ID;
					txnObj.propertyMode = m_propertyMode;
					txnObj.propertyType = m_propertyType;
					var currentDate:String = dateFormatter.format(new Date());
					getImageUpgradeDevicesStatus.url = Constants.serverurl + "imageupgrade/status" + "/" + currentDate;
					getImageUpgradeDevicesStatus.send(txnObj);
					
				}
			}
			private function onGetImageUpgradeJobStatusFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			private function onGetImageUpgradeDevicesStatus(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
				
				var asyncTxnObj:Object = event.token.message.body;
				if(asyncTxnObj && asyncTxnObj.transactionId != TXN_ID) {
					trace("Response discarded: " + asyncTxnObj.transactionId + ", " + TXN_ID);
					return;
				}
				if(imageUpgradeFixtureList.length>0)
					imageUpgradeFixtureList.removeAll();
				if(imageUpgradeGatewayList.length>0)
					imageUpgradeGatewayList.removeAll();
				if(imageUpgradeWdsList.length>0)
					imageUpgradeWdsList.removeAll();
					
				var xml:XMLDocument = new XMLDocument(event.result.toString());				
				var decoder:SimpleXMLDecoder = new SimpleXMLDecoder(true);				
				var resultObj:Object = decoder.decodeXML(xml);
				
				if(!resultObj)
					return;
				
				if(resultObj.deviceStatusList.deviceFixtures)
				(resultObj.deviceStatusList.deviceFixtures.deviceFixtureList is ArrayCollection) ? (imageUpgradeFixtureList = resultObj.deviceStatusList.deviceFixtures.deviceFixtureList) :  (imageUpgradeFixtureList.addItem(resultObj.deviceStatusList.deviceFixtures.deviceFixtureList));
				if(resultObj.deviceStatusList.deviceGateways)
				(resultObj.deviceStatusList.deviceGateways.deviceGatewayList is ArrayCollection) ? (imageUpgradeGatewayList = resultObj.deviceStatusList.deviceGateways.deviceGatewayList) :  (imageUpgradeGatewayList.addItem(resultObj.deviceStatusList.deviceGateways.deviceGatewayList));
				if(resultObj.deviceStatusList.deviceWdss)
				(resultObj.deviceStatusList.deviceWdss.deviceWdsList is ArrayCollection) ? (imageUpgradeWdsList = resultObj.deviceStatusList.deviceWdss.deviceWdsList) :  (imageUpgradeWdsList.addItem(resultObj.deviceStatusList.deviceWdss.deviceWdsList));
				
				//If upgrade status is inprogress or scheduled, it means JOB is in progress. If Image upgrade status is Sucess/Fail, it means Job has been finished.
				// Therefore stop the refresh Image upgrade timer
				var isImageUpgradeJobInProgress:Boolean= false;
				
				var fixCount:Number =0;
				var gwCount:Number=0;
				var wdsCount:Number=0;
				//Update the Fixture Status in the ArrayCollection before assigning to UI
				if(imageUpgradeFixtureList!=null && imageUpgradeFixtureList.length>0)
				{
					for each(var fixObj:Object in imageUpgradeFixtureList)
					{
						if(fixObj.status==Constants.IMG_UP_STATUS_INPROGRESS || fixObj.status==Constants.IMG_UP_STATUS_SCHEDULED)
						{
							isImageUpgradeJobInProgress = true;
						}else
						{
							if(fixObj.status==Constants.IMG_UP_STATUS_FAIL || fixObj.status==Constants.IMG_UP_STATUS_SUCCESS)
							{
								fixCount++;
							}
						}
						if(commissionedFixtureData.length>0)
						{
							for each(var fixture:Object in commissionedFixtureData)
							{
								if(fixture.id == fixObj.fixtureId)
								{
									fixture.upgradestatus=fixObj.status;
									if(fixObj.version != null)
										fixture.version=fixObj.version;
									fixture.imageUpgradeStatus = null;
									fixture.imageUpgradeStatus = fixture.snapaddress + " ("+ fixObj.status+")";
									fixture.imageUpgradeHoverStatus = fixture.name + " ("+ fixObj.status+")";
									break;
								}
							}
						}
					}
					reportsTableList.imageUpgradeFixtureData.refresh();
					commissionedFixtureData.refresh();
					FixtureIconRenderer.rendererType = Constants.IMAGE_UPGRADE;
				}
				
				//Update the Gateway Status in the ArrayCollection before assigning to UI
				if(imageUpgradeGatewayList!=null && imageUpgradeGatewayList.length>0)
				{
					for each(var gatewayObj:Object in imageUpgradeGatewayList)
					{
						if(gatewayObj.status==Constants.IMG_UP_STATUS_INPROGRESS || gatewayObj.status==Constants.IMG_UP_STATUS_SCHEDULED)
						{
							isImageUpgradeJobInProgress = true;
						}else
						{
							if(gatewayObj.status==Constants.IMG_UP_STATUS_FAIL || gatewayObj.status==Constants.IMG_UP_STATUS_SUCCESS)
							{
								gwCount++;
							}
						}
						if(commissionedGatewayData.length>0)
						{
							for each(var gateway:Object in commissionedGatewayData)
							{
								if(gateway.id == gatewayObj.gatewayId)
								{
									gateway.upgradestatus=gatewayObj.status;
									if(gatewayObj.version != null)
										gateway.app2version=gatewayObj.version;
									gateway.imageUpgradeStatus = null;
									gateway.imageUpgradeStatus = gateway.snapaddress + " ("+ gatewayObj.status+")";
									gateway.imageUpgradeHoverStatus = gateway.name + " ("+ gatewayObj.status+")";
									break;
								}
							}
						}
					}
					reportsTableList.imageUpgradeGatewayData.refresh();
					commissionedGatewayData.refresh();
					GatewayIconRenderer.gwRendererType = Constants.IMAGE_UPGRADE;
				}
				
				//Update the WDS Status in the ArrayCollection before assigning to UI
				if(imageUpgradeWdsList!=null && imageUpgradeWdsList.length>0)
				{
					for each(var wdsObj:Object in imageUpgradeWdsList)
					{
						if(wdsObj.status==Constants.IMG_UP_STATUS_INPROGRESS || wdsObj.status==Constants.IMG_UP_STATUS_SCHEDULED)
						{
							isImageUpgradeJobInProgress = true;
						}else
						{
							if(wdsObj.status==Constants.IMG_UP_STATUS_FAIL || wdsObj.status==Constants.IMG_UP_STATUS_SUCCESS)
							{
								wdsCount++;
							}
						}
						if(commissionedGatewayData.length>0)
						{
							for each(var wds:Object in wdsData)
							{
								if(wds.id == wdsObj.wdsId)
								{
									wds.upgradestatus=wdsObj.status;
									if(wdsObj.version != null)
										wds.version=wdsObj.version;
									wds.imageUpgradeStatus = null;
									wds.imageUpgradeStatus = wds.macaddress + " ("+ wdsObj.status+")";
									wds.imageUpgradeHoverStatus = wds.name + " ("+ wdsObj.status+")";
									break;
								}
							}
						}
					}
					reportsTableList.wdsData.refresh();
					wdsData.refresh();
					WdsIconRenderer.wdsRendererType = Constants.IMAGE_UPGRADE;
				}
				
				if(isImageUpgradeJobInProgress)
				{
					showToolbarViewStack=true;
					toolbarViewStack.selectedIndex=3;
					
					//If Mode is Image Upgrade then start the Auto Timer to refresh the Image Upgrade device status
					autoRefreshTimer.addEventListener(TimerEvent.TIMER, onAutoRefreshTimerComplete);
					autoRefreshTimer.start();
				}
				var allDeviceStatusRecived:Boolean =false;
				if(imageUpgradeFixtureList.length == fixCount && imageUpgradeGatewayList.length == gwCount && imageUpgradeWdsList.length == wdsCount)
				{
					allDeviceStatusRecived = true;
				}
				if(allDeviceStatusRecived)
				{
					if(autoRefreshTimer && autoRefreshTimer.running)
					{
						autoRefreshTimer.stop();
						ExternalInterface.call("clearAllImageUpgradeStatusMsg");
						showToolbarViewStack=false;
					}
				}
				
			}
			private function onGetImageUpgradeDevicesStatusFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			private function onAutoRefreshTimerComplete(event:TimerEvent):void
			{
				//Get the Image upgrade device status
				var txnObj:Object = new Object();
				txnObj.transactionId = TXN_ID;
				txnObj.propertyMode = m_propertyMode;
				txnObj.propertyType = m_propertyType;
				var currentDate:String = dateFormatter.format(new Date());
				getImageUpgradeDevicesStatus.url = Constants.serverurl + "imageupgrade/status" + "/" + currentDate;
				getImageUpgradeDevicesStatus.send(txnObj);
				
				FlexGlobals.topLevelApplication.showAlertMarquee("Refreshing...", true);
			}
			private function onUpdateGroupSyncFlagTimerComplete(event:TimerEvent):void
			{
				//check the last conectivity time with switch edit ox if excede the 
				updateSwitchGroupSyncFlag.url = Constants.serverurl + "switch/lastTimeValidation/?ts=" + new Date().time;
				updateSwitchGroupSyncFlag.send();
			}
			private function onUpdateSwitchGroupSyncFlag(event:ResultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			private function onUpdateSwitchGroupSyncFlagFailure(event:FaultEvent):void
			{
				// Check for session timeout
				if(event.statusCode == Constants.SESSION_TIME_OUT)
				{
					// Session timedout; show login page
					GlobalUtils.LogOut();
					return;
				}
			}
			private function onPanImageClick(event:MouseEvent) : void
			{
				floorPlanChart.selectionMode = "single";
				panCanvas.panningEnabled = true;
				panEnabled = true;
				panSelectionImage.source = Images.PanSelectionEnabled;
				multipleSelectionImage.source = Images.MultipleSelection;
			}
			
			private function onMultipleSelectionImageClick(event:MouseEvent) : void
			{
				floorPlanChart.selectionMode = "multiple";
				panCanvas.panningEnabled = false;
				panEnabled = false;
				panSelectionImage.source = Images.PanSelection;
				multipleSelectionImage.source = Images.MultipleSelectionEnabled;
			}
			
			private function onKeyUp(event:KeyboardEvent) : void
			{
				if(event.ctrlKey && (event.keyCode == 90))
				{
					if(localFixtureData != null && localFixtureData.length > 0)
					{
						commissionedFixtureData = localFixtureData;
						updateFixturePosition(commissionedFixtureData);
					}
					
					if(localGatewayData != null && localGatewayData.length > 0)
					{
						commissionedGatewayData = localGatewayData;
						updateGatewayPosition(commissionedGatewayData);
					}
					
					if(localSwitchData != null && localSwitchData.length > 0)
					{
						switchesData = localSwitchData;
						updateSwitchPosition(switchesData);
					}
					if(localLocatorDeviceData != null && localLocatorDeviceData.length > 0)
					{
						locatorDeviceData = localLocatorDeviceData;
						updateLocatorDevicePosition(locatorDeviceData);
					}
					
					if(selectedItems.length == 0)
						return;
					
					for(var i:int=0; i<selectedItems.length; i++)
					{
						if(localFixtureData != null && selectedItems[i].item.type == Constants.FIXTURE)
						{
							for(var j:int=0; j<commissionedFixtureData.length; j++)
							{
								if(commissionedFixtureData[j].id == selectedItems[i].item.id)
								{
									selectedItems[i].item = commissionedFixtureData[j];
									break;
								}
							}
						}
						else if(localGatewayData != null && selectedItems[i].item.type == Constants.GATEWAY)
						{
							for(var k:int=0; k<commissionedGatewayData.length; k++)
							{
								if(commissionedGatewayData[k].id == selectedItems[i].item.id)
								{
									selectedItems[i].item = commissionedGatewayData[k];
								}
							}
						}
						else if(localSwitchData != null && selectedItems[i].item.type == Constants.SWITCH)
						{
							for(var l:int=0; l<switchesData.length; l++)
							{
								if(switchesData[l].id == selectedItems[i].item.id)
								{
									selectedItems[i].item = switchesData[l];
								}
							}
						}
						else if(localLocatorDeviceData != null && selectedItems[i].item.type == Constants.LOCATORDEVICE)
						{
							for(var m:int=0; m<localLocatorDeviceData.length; m++)
							{
								if(localLocatorDeviceData[m].id == selectedItems[i].item.id)
								{
									selectedItems[i].item = localLocatorDeviceData[m];
								}
							}
						}
					}
				}
				
				localFixtureData = null;
				localGatewayData = null;
				localSwitchData = null;
				localLocatorDeviceData = null;
			}
			
			private function setCursor(event:MouseEvent) : void
			{
				if((event.target is PlotChart) && (panCanvas.panningEnabled))
				{
					panCanvas.cursorManager.setCursor(Images.PanningCursor)
				}
			}
			
			private function createFloorPlanContextMenu() : void
			{
				commissionContextMenu = null;
				floorPlanContextMenu = new ContextMenu();
				
				for (var i:uint = 0; i<floorPlanContextMenuItems.length; i++) 
				{
					var menuItem:ContextMenuItem = new ContextMenuItem(floorPlanContextMenuItems[i]);
					if(m_userRole == Constants.EMPLOYEE)
					{
						if(menuItem.caption == Constants.ASSIGN_PROFILE)
						{
							floorPlanContextMenu.customItems.push(menuItem);
							menuItem.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, handleFloorPlanContextMenu);
							break;
						}
					}else
					{
						if(menuItem.caption == Constants.ASSIGN_USERS || menuItem.caption == Constants.ASSIGN_PROFILE || menuItem.caption == Constants.UNASSIGN_GROUPS || menuItem.caption == Constants.CREATE_OTHER_DEVICES)
						{
							menuItem.separatorBefore = true;
						}
						floorPlanContextMenu.customItems.push(menuItem);
						menuItem.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, handleFloorPlanContextMenu);
					}
				}
				
				floorPlanContextMenu.hideBuiltInItems();
				floorPlanChart.contextMenu = floorPlanContextMenu;
				
				floorPlanContextMenu.addEventListener(ContextMenuEvent.MENU_SELECT, onOpenContextMenu);
				
				manageFloorPlanContextMenu();
			}
			
			// This function iterates through a selectedItems list and returns true
			// if the searchItem is found in the list
			private function isSelected(searchItem:Object) : Boolean
			{
				var arrayLength:int = selectedItems.length;
				
				for (var j:int=0; j<arrayLength; j++)
				{
					if(selectedItems[j] is PlotSeriesItem)
					{
						if(selectedItems[j].item.id == searchItem.id)
						{
							return true;
						}
					}
					else
					{
						if(selectedItems[j].id == searchItem.id)
						{
							return true;
						}
					}
				}
				return false;
			}
			
			private function onOpenContextMenu(event:ContextMenuEvent) : void
			{
				if(mouseOverFixture)
				{
					// If we are right clicking on the device that is already selected then do not do anything with the current selection
					if(isSelected(mouseOverFixture) == false)
					{					
						removeSelection();
						selectedItems.push(mouseOverFixture);
						selectedFixtures.addItem(mouseOverFixture);
						applyFilters(mouseOverFixture, "glowFilter");
					}
					manageDeviceContextMenu();
				}
				else if(mouseOverGateway)
				{
					// If we are right clicking on the device that is already selected then do not do anything with the current selection
					if(isSelected(mouseOverGateway) == false)
					{					
						removeSelection();
						selectedItems.push(mouseOverGateway);
						selectedGateways.addItem(mouseOverGateway);
						applyFilters(mouseOverGateway, "glowFilter");
					}
					manageDeviceContextMenu();
				}
				else if(mouseOverSwitch)
				{
					// If we are right clicking on the device that is already selected then do not do anything with the current selection
					if(isSelected(mouseOverSwitch) == false)
					{					
						removeSelection();
						selectedItems.push(mouseOverSwitch);
						selectedSwitches.addItem(mouseOverSwitch);
						applyFilters(mouseOverSwitch, "glowFilter");
					}
					manageDeviceContextMenu();
				}
				else if(mouseOverWds)
				{
					// If we are right clicking on the device that is already selected then do not do anything with the current selection
					if(isSelected(mouseOverWds) == false)
					{					
						removeSelection();
						selectedItems.push(mouseOverWds);
						selectedWds.addItem(mouseOverWds);
						applyFilters(mouseOverWds, "glowFilter");
					}
					manageDeviceContextMenu();
				}
				else if(mouseOverLocatorDevice)
				{
					// If we are right clicking on the device that is already selected then do not do anything with the current selection
					if(isSelected(mouseOverLocatorDevice) == false)
					{					
						removeSelection();
						selectedItems.push(mouseOverLocatorDevice);
						selectedLocatorDevices.addItem(mouseOverLocatorDevice);
						applyFilters(mouseOverLocatorDevice, "glowFilter");
					}
					manageDeviceContextMenu();
				}
				else
				{
					manageFloorPlanContextMenu();
				}
			}
			
			private function handleFloorPlanContextMenu(event:ContextMenuEvent):void 
			{
				var selFixtures:String = "[";
				var sep:String = "";
				var fixtureItem:Object
				
				switch(ContextMenuItem(event.target).caption)
				{
					case Constants.ASSIGN_PROFILE : 
						if(ExternalInterface.available)
						{
							for(var i:int=0; i<selectedFixtures.length; i++)
							{
								if(selectedFixtures[i] is PlotSeriesItem)
								{
									selFixtures += sep + "{id: " + selectedFixtures[i].item.id + ", currentprofile: \"" + selectedFixtures[i].item.currentprofile + "\"}";
								}
								else
								{
									selFixtures += sep + "{id: " + selectedFixtures[i].id + ", currentprofile: \"" + selectedFixtures[i].currentprofile + "\"}";
								}
								sep = ",";
							}
							selFixtures += "]";  
							ExternalInterface.call("assignProfileToFixtures", selFixtures,m_userRole);
						}
						break;
					case Constants.ASSIGN_SUITE : 
						if(ExternalInterface.available)
						{
							for(var j:int=0; j<selectedFixtures.length; j++)
							{
								if(selectedFixtures[j] is PlotSeriesItem)
								{
									selFixtures += sep + "{id: " + selectedFixtures[j].item.id + "}";
								}
								else
								{
									selFixtures += sep + "{id: " + selectedFixtures[j].id + "}";
								}
								sep = ",";
							}
							selFixtures += "]";  
							ExternalInterface.call("assignAreaToFixtures", selFixtures);
						}
						break;
					case Constants.DEFINE_GROUP_BEHAVIOUR : 
						if(ExternalInterface.available)
						{
							for(var k:int=0; k<selectedFixtures.length; k++)
							{
								if(selectedFixtures[k] is PlotSeriesItem)
								{
									selFixtures += sep + "{id: " + selectedFixtures[k].item.id + ", name: \"" + selectedFixtures[k].item.name + "\", version: \"" + selectedFixtures[k].item.version  + "\"}";
								}
								else
								{
									selFixtures += sep + "{id: " + selectedFixtures[k].id + ", name: \"" + selectedFixtures[k].name +  "\", version: \"" + selectedFixtures[k].version  + "\"}";
								}
								sep = ",";
							}
							selFixtures += "]";  
							ExternalInterface.call("assignGemsGroupToFixtures", selFixtures);
						}
						break;
					case Constants.DEFINE_SWITCH_BEHAVIOUR : 
						if(ExternalInterface.available)
						{
							for(var l:int=0; l<selectedFixtures.length; l++)
							{
								if(selectedFixtures[l] is PlotSeriesItem)
								{
									selFixtures += sep + "{id: " + selectedFixtures[l].item.id + "}";
								}
								else
								{
									selFixtures += sep + "{id: " + selectedFixtures[l].id + "}";
								}
								sep = ",";
							}
							selFixtures += "]";  
							ExternalInterface.call("showSwitchForm", "", selFixtures, event.contextMenuOwner.mouseX, (maxYaxis - event.contextMenuOwner.mouseY));
						}
						break;
					case Constants.DEFINE_MOTION_BITS_BEHAVIOUR : 
						if(ExternalInterface.available)
						{
							for(var p:int=0; p<selectedFixtures.length; p++)
							{
								if(selectedFixtures[p] is PlotSeriesItem)
								{
									selFixtures += sep + "{id: " + selectedFixtures[p].item.id + ", name: \"" + selectedFixtures[p].item.name + "\", version: \"" + selectedFixtures[p].item.version  + "\"}";
								}
								else
								{
									selFixtures += sep + "{id: " + selectedFixtures[p].id + ", name: \"" + selectedFixtures[p].name +  "\", version: \"" + selectedFixtures[p].version  + "\"}";
								}
								sep = ",";
							}
							selFixtures += "]";  
							ExternalInterface.call("showMotionBitsForm", selFixtures);
						}
						break;
					case Constants.AUTO_LIGHT_LEVEL : 
						onAutoSelect();
						break;
					case Constants.UNASSIGN_GROUPS :
						
						if(ExternalInterface.available)
						{
							var count:int;
							var versionNumber:int;
							for(var n:int=0; n<selectedFixtures.length; n++)
							{
								if(selectedFixtures[n] is PlotSeriesItem)
								{
									versionNumber = selectedFixtures[n].item.version.substr(0, selectedFixtures[n].item.version.indexOf("."));
									if(versionNumber >= 2)
									{
										selFixtures += sep + "{id: " + selectedFixtures[n].item.id + "}";
										count++;
									}
									
								}
								else
								{
									versionNumber = selectedFixtures[n].version.substr(0, selectedFixtures[n].version.indexOf("."));
									if(versionNumber >= 2)
									{
										selFixtures += sep + "{id: " + selectedFixtures[n].id + "}";
										count++;
									}
								}
								sep = ",";
							}
							selFixtures += "]"; 
							
							if(count == 0)
							{
								Alert.show("Please select sensors of 2.0+ version");
								return;
							}
							else
							{
								var alertText:String = "Number of selected sensors (2.0+) : " + count + "\n" + "Do you want to continue?"; 
								Alert.show(alertText, Constants.UNASSIGN_GROUPS, Alert.OK | Alert.CANCEL, this, addArguments(resetAlertHandler, selFixtures), null, Alert.OK);
							}
						}
						break;
					case Constants.ASSIGN_USERS : 
						if(ExternalInterface.available)
						{
							var selSwitches:String;
							selSwitches = "[";
							
							for(var m:int=0; m<selectedSwitches.length; m++)
							{
								if(selectedSwitches[m] is PlotSeriesItem)
								{
									selSwitches += sep + "{id: " + selectedSwitches[m].item.id + "}";
								}
								else
								{
									selSwitches += sep + "{id: " + selectedSwitches[m].id + "}";
								}
								sep = ",";
							}
							selSwitches += "]";  
							ExternalInterface.call("assignUserToSwitches", selSwitches);
						}
						break;
					case Constants.CREATE_OTHER_DEVICES : 
						if(ExternalInterface.available)
						{
						  ExternalInterface.call("showLocatorDeviceForm", "", event.contextMenuOwner.mouseX, (maxYaxis - event.contextMenuOwner.mouseY), Constants.FLOORPLAN);
						}
						break;
					case Constants.SET_SWITCH_POSITION : 
							
						if (this.placeHoldersData == null) {
							devicePosition.x = int(placeHoldersSeries.localToData(new Point(floorPlanChart.mouseX,floorPlanChart.mouseY))[0]);
							devicePosition.y = int(placeHoldersSeries.localToData(new Point(floorPlanChart.mouseX,floorPlanChart.mouseY))[1]);
							
							var pHolder:PlaceHolder = new PlaceHolder();
							pHolder.xaxis = devicePosition.x;
							pHolder.yaxis = devicePosition.y;
							
							this.placeHoldersData = new ArrayCollection();
							this.placeHoldersData.addItem(pHolder);
							
							var oSwitch:Object = null;
							for(var ii:int=0; ii<switchesData.length; ii++)
							{
								if(switchesData[ii].id == m_switchId)
								{
									if (devicePosition.x > 0 && devicePosition.y > 0) 
									{
										switchesData[ii].xaxis = devicePosition.x;
										switchesData[ii].yaxis = devicePosition.y;
									} else { 
										switchesData[ii].xaxis = int((panCanvas.horizontalScrollPosition) / (floorPlanChart.scaleX) + (12 * floorPlanChart.scaleX)) + 30;
										switchesData[ii].yaxis = int(maxYaxis - (panCanvas.verticalScrollPosition) / (floorPlanChart.scaleY) - (12 * floorPlanChart.scaleY)) - 30;
									}
									resetDevicePosition();
									switchesData[ii].state = Constants.COMMISSIONED;
									oSwitch = switchesData[ii];
									break;
								}
							}
							if(oSwitch)
							{
								FlexGlobals.topLevelApplication.showAlertMarquee("Positioning switch " + oSwitch.id + ", " + oSwitch.xaxis + ", " + oSwitch.yaxis, true);
								var switchXmlList:XML = XML("<switches><switch><id>" + m_switchId + "</id><xaxis>" + oSwitch.xaxis + "</xaxis><yaxis>" + oSwitch.yaxis + "</yaxis></switch></switches>");
								updateSwitchPositionHttpService.url = Constants.serverurl + "switch/du/updateposition" + "/?ts=" + new Date().time;
								updateSwitchPositionHttpService.request = switchXmlList;
								updateSwitchPositionHttpService.send();
								switchesData.refresh();
							}
						}
						break;
				}
			}
			
			private function addArguments(method:Function, str:String):Function 
			{
				return function(event:Event):void {method.apply(null, [event].concat(str));}
			}
			
			private function resetAlertHandler(eventObj:CloseEvent, selFixtures:String) : void
			{
				if (eventObj.detail==Alert.OK)
				{
					if(ExternalInterface.available)
					{
						ExternalInterface.call("resetFixtureGemsGroups", selFixtures);
					}
				}
			}
			
			private function createCommissionContextMenu() : void
			{
				floorPlanContextMenu = null;
				commissionContextMenu = new ContextMenu();
				
				for (var i:uint = 0; i<commissionContextMenuItems.length; i++) 
				{
					var menuItem:ContextMenuItem;
					if(m_propertyModeId == Constants.FIXTURE_COMMISSION ){
						menuItem = new ContextMenuItem(commissionContextMenuItems[i]);
						if(menuItem.caption == Constants.CREATE_OTHER_DEVICES ){
							menuItem.separatorBefore = true;
						}
						menuItem.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, handleCommissionContextMenu);
						commissionContextMenu.customItems.push(menuItem);
					}
					else{
						menuItem = new ContextMenuItem(commissionContextMenuItems[i]);
						if(menuItem.caption != Constants.CREATE_OTHER_DEVICES ){
							menuItem.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, handleCommissionContextMenu);
							commissionContextMenu.customItems.push(menuItem);
						}
					}
				}
				
				commissionContextMenu.addEventListener(ContextMenuEvent.MENU_SELECT, onOpenCommissionContextMenu);
				
				commissionContextMenu.hideBuiltInItems();
				panCanvas.contextMenu = commissionContextMenu;
			}
			
			private function onOpenCommissionContextMenu(event:ContextMenuEvent) : void
			{
				// If only one fixture is selected in the fixturePlotSeries then display RMA menu
				if(fixturePlotSeries.selectedIndex == -1)
					commissionContextMenu.customItems[1].visible = false;
				else
					commissionContextMenu.customItems[1].visible = true;

				// Fix for ENL-2758
				// In Chrome MENU_SELECT gets called when the righ mouse button is clicked and MENU_ITEM_SELECT handler is called when the menu
				// item is selcted. So the devicePosition setting is moved here from handleCommissionContextMenu
				// In Firefoex, both the handlers are called with the position for the right click
				devicePosition.x = int(placeHoldersSeries.localToData(new Point(floorPlanChart.mouseX,floorPlanChart.mouseY))[0]);
				devicePosition.y = int(placeHoldersSeries.localToData(new Point(floorPlanChart.mouseX,floorPlanChart.mouseY))[1]);
			}
			
			private function handleCommissionContextMenu(event:ContextMenuEvent) : void
			{
				switch(ContextMenuItem(event.target).caption)
				{
					case Constants.COMMISSION_AND_PLACE : 
						if(ExternalInterface.available)
						{
							if (this.placeHoldersData == null) {
								var pHolder:PlaceHolder = new PlaceHolder();
								pHolder.xaxis = devicePosition.x;
								pHolder.yaxis = devicePosition.y;
								
								this.placeHoldersData = new ArrayCollection();
								this.placeHoldersData.addItem(pHolder);
								if (commissionContextMenu != null) {
									var cmipos:ContextMenuItem = commissionContextMenu.customItems[0];
									cmipos.enabled = false;
								}
								// Call Commission & Place
								ExternalInterface.call("commissionDevice");
							}
						}
						break;
					case Constants.RMA : 
						if(ExternalInterface.available)
						{
							ExternalInterface.call("rmaDevice", fixturePlotSeries.selectedItem.item.id, fixturePlotSeries.selectedItem.item.name);
						}
						break;
					case Constants.CREATE_OTHER_DEVICES : 
						if(ExternalInterface.available)
						{
							ExternalInterface.call("showLocatorDeviceForm", "", devicePosition.x, devicePosition.y, Constants.COMMISSION);
						}
						break;
				}
			}
			
			private function imgHttpStatus(evt:HTTPStatusEvent):void
			{
				switch (evt.status) 
				{
					case 200: // Valid image, do nothing.
						break;
					default:
						img.source = Images.DefaultFloorPlan;
						fitImageToScreen(null);
						break;
				}
			}
			
			private function resetData() : void
			{
				selectedFixtures.removeAll();
				selectedGateways.removeAll();
				selectedSwitches.removeAll();
				selectedWds.removeAll();
				selectedLocatorDevices.removeAll();
			}
			
			// NOTE: DO NOT DELETE/ UNCOMMENT THE COMMENTED CODE. 
			//THIS MIGHT BE REUSED. 
			//IF NOT REUSED, WILL BE CLEANED UP DURING CODE CLEAN UP AND OPTIMIZATION PHASE.
			
			/* private function pan(event:MouseEvent) : void
			{
			timer = new Timer(75);
			
			switch(event.currentTarget.id)
			{
			case "panUpButton":	
			timer.addEventListener( TimerEvent.TIMER, panUp);
			break;
			case "panDownButton":	
			timer.addEventListener( TimerEvent.TIMER, panDown);
			break;
			case "panLeftButton":	
			timer.addEventListener( TimerEvent.TIMER, panLeft);
			break;
			case "panRightButton":	
			timer.addEventListener( TimerEvent.TIMER, panRight);
			break;
			}
			timer.start();
			}
			
			private function panUp(event:TimerEvent) : void
			{
			if(panCanvas.verticalScrollBar && panCanvas.verticalScrollPosition >0)
			{
			panCanvas.verticalScrollPosition = panCanvas.verticalScrollPosition - 20;
			}
			}
			
			private function panDown(event:TimerEvent) : void
			{
			if(panCanvas.verticalScrollBar && panCanvas.verticalScrollPosition < panCanvas.maxVerticalScrollPosition)
			{
			panCanvas.verticalScrollPosition = panCanvas.verticalScrollPosition + 20;
			}
			}
			
			private function panLeft(event:TimerEvent) : void
			{
			if(panCanvas.horizontalScrollBar && panCanvas.horizontalScrollPosition >0)
			{
			panCanvas.horizontalScrollPosition = panCanvas.horizontalScrollPosition - 20;
			}
			}
			
			private function panRight(event:TimerEvent) : void
			{
			if(panCanvas.horizontalScrollBar && panCanvas.horizontalScrollPosition < panCanvas.maxHorizontalScrollPosition)
			{
			panCanvas.horizontalScrollPosition = panCanvas.horizontalScrollPosition + 20;
			}
			}
			
			private function stopPan(event:MouseEvent) : void
			{
			timer.stop();
			}
			
			private function createOutageFilters() : void
			{
			almostDeadFixtureData.removeAll();
			midlifeFixtureData.removeAll();
			fullHealthFixtureData.removeAll();
			
			
			if(fixturePlotSeries.items.length == 0)
			return;
			
			for(var i:int = 0; i<commissionedFixtureData.length; i++)
			{
			var obj:Object = commissionedFixtureData.getItemAt(i);
			if (obj.bulblife < 25)
			{
			almostDeadFixtureData.addItem(obj);
			fixturePlotSeries.getChildAt(i).filters = [almostDeadGlowFilter];
			}						
			else if(obj.bulblife < 75 && obj.bulblife >= 25)
			{
			midlifeFixtureData.addItem(obj);
			fixturePlotSeries.getChildAt(i).filters = [midlifeGlowFilter];
			}
			else
			{
			fullHealthFixtureData.addItem(obj);
			fixturePlotSeries.getChildAt(i).filters = [fullHealthGlowFilter];
			}
			}
			searchData = new ArrayCollection(clone(commissionedFixtureData.source));
			}
			
			private function removeBulbFilters() : void
			{
			for(var i:int = 0; i<fixturePlotSeries.dataProvider.length; i++)
			{
			var obj:Object = Object(fixturePlotSeries.getChildAt(i)).data.item;
			fixturePlotSeries.getChildAt(i).filters = [];
			}
			searchData = new ArrayCollection(clone(fullSearchData.source));
			}
			
			private function filterBulbReport(event:MouseEvent) : void
			{
			switch(event.currentTarget.label)
			{
			case Constants.ALL_FIXTURES : 
			fixturePlotSeries.dataProvider = commissionedFixtureData;
			for(var i:int = 0; i<fixturePlotSeries.dataProvider.length; i++)
			{
			var obj:Object = Object(fixturePlotSeries.getChildAt(i)).data.item;
			if (obj.bulblife < 25)
			{
			fixturePlotSeries.getChildAt(i).filters = [almostDeadGlowFilter];
			}						
			else if(obj.bulblife < 75 && obj.bulblife >= 25)
			{
			fixturePlotSeries.getChildAt(i).filters = [midlifeGlowFilter];
			}
			else
			{
			fixturePlotSeries.getChildAt(i).filters = [fullHealthGlowFilter];
			}
			}
			break;
			
			case Constants.ALMOST_DEAD : 
			fixturePlotSeries.dataProvider = almostDeadFixtureData;
			for(var m:int = 0; m<fixturePlotSeries.dataProvider.length; m++)
			{
			fixturePlotSeries.getChildAt(m).filters = [almostDeadGlowFilter];
			}
			break;
			
			case Constants.MIDLIFE_CRISIS : 
			fixturePlotSeries.dataProvider = midlifeFixtureData;
			for(var j:int = 0; j<fixturePlotSeries.dataProvider.length; j++)
			{
			fixturePlotSeries.getChildAt(j).filters = [midlifeGlowFilter];
			}
			break;
			
			case Constants.FULL_HEALTH : 
			fixturePlotSeries.dataProvider = fullHealthFixtureData;
			for(var k:int = 0; k<fixturePlotSeries.dataProvider.length; k++)
			{
			fixturePlotSeries.getChildAt(k).filters = [fullHealthGlowFilter];
			}
			break;
			}
			}
			
			private function alignComponents(event:MouseEvent, str:String):void
			{
			switch(str)
			{
			case "halign" : 
			alignHorizontally(event);
			break;
			
			case "valign" : 
			alignVertically(event);
			break;
			}
			}
			
			private function alignHorizontally(event:MouseEvent):void
			{
			var minMaxArr:Array=findMinValue(selectedItems);
			var minYaxis:Number = minMaxArr["Xmin"];
			createLocalData();
			
			resetData();
			
			for each (var plotSeriesItem:PlotSeriesItem in selectedItems)
			{
			plotSeriesItem.item.yaxis = minYaxis;
			
			if(plotSeriesItem.itemRenderer.name == Constants.FIXTURE_RENDERER)
			selectedFixtures.addItem(plotSeriesItem.item);
			else if(plotSeriesItem.itemRenderer.name == Constants.GATEWAY_RENDERER)
			selectedGateways.addItem(plotSeriesItem.item);
			else if(plotSeriesItem.itemRenderer.name == Constants.SWITCH_RENDERER)
			selectedSwitches.addItem(plotSeriesItem.item);
			}
			
			if(selectedFixtures.length > 0)
			updateFixturePosition(selectedFixtures);
			if(selectedGateways.length > 0)
			updateGatewayPosition(selectedGateways);
			if(selectedSwitches.length > 0)
			updateSwitchPosition(selectedSwitches);
			}
			
			private function alignVertically(event:MouseEvent):void
			{
			var minMaxArr:Array=findMinValue(selectedItems);
			var minXaxis:Number = minMaxArr["Ymin"];
			createLocalData();
			
			resetData();
			
			for each (var plotSeriesItem:PlotSeriesItem in selectedItems)
			{
			plotSeriesItem.item.xaxis = minXaxis;
			
			if(plotSeriesItem.itemRenderer.name == Constants.FIXTURE_RENDERER)
			selectedFixtures.addItem(plotSeriesItem.item);
			else if(plotSeriesItem.itemRenderer.name == Constants.GATEWAY_RENDERER)
			selectedGateways.addItem(plotSeriesItem.item);
			else if(plotSeriesItem.itemRenderer.name == Constants.SWITCH_RENDERER)
			selectedSwitches.addItem(plotSeriesItem.item);
			}
			
			if(selectedFixtures.length > 0)
			updateFixturePosition(selectedFixtures);
			if(selectedGateways.length > 0)
			updateGatewayPosition(selectedGateways);
			if(selectedSwitches.length > 0)
			updateSwitchPosition(selectedSwitches);
			}
			
			private function findMinValue(val:Array):Array
			{
			var minMaxArr:Array = new Array();
			var cnt:Number=0;
			//Find the minimum xaxis and Yaxis of the first selected Object.
			var plotSeriesObj:PlotSeriesItem = selectedItems[0] as PlotSeriesItem;
			minMaxArr["Xmin"] = plotSeriesObj.item.yaxis;
			minMaxArr["Ymin"] = plotSeriesObj.item.xaxis;
			return minMaxArr;
			}
			
			private function showDataTip(data:HitData) : String
			{
			var dataTipDetails:String = "";
			if(data.chartItem.itemRenderer.name == Constants.FIXTURE_RENDERER)
			{
			if(showFullDeatils)
			{
			dataTipDetails = getDeviceNameString(data.item.name);
			dataTipDetails = dataTipDetails + "\n" + getDimmerControlString(data.item.lightlevel);
			dataTipDetails = dataTipDetails + "; " + wattPrecision(Number(data.item.wattage));
			dataTipDetails = dataTipDetails + "; " + getTemperatureString(data.item.avgtemperature);
			dataTipDetails = dataTipDetails + "\n" + getLightLevelString(data.item.ambientlight);
			dataTipDetails = dataTipDetails + "\n" + getOccupancyString(data.item.lastoccupancyseen);
			dataTipDetails = dataTipDetails + "\nProfile: " +  data.item.currentprofile;
			if(data.item.state != null && data.item.state != "")
			dataTipDetails = dataTipDetails + "\nMode: " + data.item.state;
			}
			else
			{
			dataTipDetails = getDeviceNameString(data.item.name);
			dataTipDetails = dataTipDetails + "\n(";
			dataTipDetails = dataTipDetails + "last connected at " + dateFormatter.format(createDate(data.item.lastconnectivityat));
			dataTipDetails = dataTipDetails + ")";
			if(data.item.state.toUpperCase() == "DISABLED")
			{
			dataTipDetails = dataTipDetails + "\nMode: Disabled";
			}
			else
			{
			dataTipDetails = dataTipDetails + "\nProfile: " +  data.item.currentprofile;
			}
			}
			}
			else if(data.chartItem.itemRenderer.name == Constants.GATEWAY_RENDERER)
			{
			if(showFullDeatils)
			{
			dataTipDetails = getDeviceNameString(data.item.name);
			dataTipDetails = dataTipDetails + "\nBound fixtures: " + data.item.noofsensors.toString();
			}
			else
			{
			dataTipDetails = getDeviceNameString(data.item.name);
			dataTipDetails = dataTipDetails + "\n(";
			dataTipDetails = dataTipDetails + "last connected at " + dateFormatter.format(createDate(data.item.lastconnectivityat));
			dataTipDetails = dataTipDetails + ")";
			}
			}
			else if(data.chartItem.itemRenderer.name == Constants.GATEWAY_RENDERER)
			{
			dataTipDetails = getDeviceNameString(data.item.name);
			}
			return dataTipDetails;
			}
			
			private function getDeviceNameString(name:String):String
			{
			if(name.length == 0)
			return "-";
			if(name.length > 20)
			return name.substr(0, 20) + "..";
			else
			return name;
			}
			
			private function getDimmerControlString(value:int):String
			{
			if(value == 0)
			return "Off";
			else if(value == 100)
			return "Full On";
			else
			return "On (" + value + "%)";
			}
			
			private function wattPrecision(value:Number) : String
			{
			if(!value)
			return "-";
			else if (value >= 1000000)
			return (value/1000000).toFixed(2) +" MW";
			else if (value >= 1000)
			return (value/1000).toFixed(2) +" kW";
			else
			return value.toFixed(2) + " W";
			}
			
			private function getTemperatureString(num:Number):String
			{
			if(num > 82)
			return "Hot (" + num + " F)";
			else if(num > 75)
			return "Warm (" + num + " F)";
			else if(num > 68)
			return "Normal (" + num + " F)";
			else if(num > 65)
			return "Cool (" + num + " F)";
			else if(num > 0)
			return "Cold (" + num + " F)";
			else
			return "N/A";
			}
			
			private function getLightLevelString(iLightLevel:Number):String
			{
			//iLightLevel = Math.round(iLightLevel / 10);
			if(iLightLevel > 65)
			return "Bright (~ " + iLightLevel + " foot candles)";
			else if(iLightLevel > 30)
			return "Normal (~ " + iLightLevel + " foot candles)";
			else if(iLightLevel > 10)
			return "Dim (~ " + iLightLevel + " foot candles)";
			else
			return "Dark (~ " + iLightLevel + " foot candles)";
			}
			private function getOccupancyString(strOccValue:Number):String
			{
			var date:Date = new Date(0, 0, 0, 0, 0, strOccValue, 0);
			if(date.getDay() > 0)
			{
			if(date.getHours() > 0)
			return "Occupied: " + date.getDay().toString() + " days, " + date.getHours().toString() + " hrs ago";
			else
			return "Occupied:" + date.getDay().toString() + " days ago";
			}
			else if(date.getHours() > 0)
			{
			if(date.getMinutes() > 0)
			return "Occupied: " + date.getHours().toString() + " hrs, " + date.getMinutes().toString() + " min ago";
			else
			return "Occupied: " + date.getHours().toString() + " hrs ago";
			}
			else if(date.getMinutes() > 0)
			{
			if(date.getSeconds() > 0)
			return "Occupied: " + date.getMinutes().toString() + " min, " + date.getSeconds().toString() + " sec ago";
			else
			return "Occupied: " + date.getMinutes().toString() + " min ago";
			}
			else
			return "Occupied: " + date.getSeconds().toString() + " sec ago";
			}
			
			public function loadHome() : void
			{
			floorPlanChart.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);
			removeBulbFilters();
			}
			
			public function loadReports() : void
			{
			floorPlanChart.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);
			removeSelection();
			createOutageFilters();
			lockDragDropCheck.selected = true;
			} */
			
			private function onDataTipTimerComplete(event:TimerEvent) : void
			{
				if(dataTipTimer)
				{
					dataTipTimer.stop();
					dataTipTimer = null;
				}
				showDataTip();
			}
			
			private var dataTipRenderer:DataTipRenderer;
			
			private function showDataTip() : void
			{
				dataTipRenderer = new DataTipRenderer();
				var obj:Object;
				if(mouseOverFixture)
				{
					obj = mouseOverFixture;
				}
				else if(mouseOverGateway)
				{
					obj = mouseOverGateway;
				}
				else if(mouseOverSwitch)
				{
					obj = mouseOverSwitch;
				}
				else if(mouseOverWds)
				{
					obj = mouseOverWds;
				}
				else if(mouseOverLocatorDevice)
				{
					obj = mouseOverLocatorDevice;
				}
				else return;
				
				buildDataTip(obj);
				
				panCanvas.addChild(dataTipRenderer);
			}
			
			private function buildDataTip(obj:Object) : void
			{
				dataTipRenderer.obj = obj;
				dataTipRenderer.setBackgroundColor(toolTipColor);
				
				if(m_propertyMode != Constants.FLOORPLAN)
				{
					positionDataTip();
					return;
				}
				
				if(obj.lastconnectivityat)
				{
					var serverTime:Date = getServerTime();
					serverTime.setMinutes(serverTime.getMinutes() - 15);
					
					var lastConnectivityTime:Date = createDate(obj.lastconnectivityat);
					
					if(lastConnectivityTime <= serverTime)
					{
						dataTipRenderer.connectivityDelay = true;
						positionDataTip();
						panCanvas.addChild(dataTipRenderer);
						return;
					}
				}
				
				positionDataTip();
			}
			
			private function positionDataTip() : void
			{
				if(panCanvas.width - mouseX >= dataTipRenderer.width)
				{
					dataTipRenderer.x = panCanvas.contentMouseX;
				}
				else
				{
					dataTipRenderer.x = panCanvas.contentMouseX - dataTipRenderer.width;
				}
				
				if(panCanvas.height - mouseY >= dataTipRenderer.height)
				{
					dataTipRenderer.y = panCanvas.contentMouseY;
				}
				else
				{
					dataTipRenderer.y = panCanvas.contentMouseY - dataTipRenderer.height;
				}
			}
			
			private function hideDataTip() : void
			{
				if(dataTipTimer)
				{
					dataTipTimer.stop();
					dataTipTimer = null;
				}
				if(dataTipRenderer && panCanvas.contains(dataTipRenderer))
				{
					panCanvas.removeChild(dataTipRenderer);
					dataTipRenderer = null;
				}
			}
			
			private function onItemRollOver(event:ChartItemEvent) : void
			{
				// When the fixtures are placed too close to each other then itemRollOver might come before itemRollOut resulting in
				// dangling tool tips. so clear the tool tip in case this happens.
				hideDataTip();
				mouseOverFixture = null;
				mouseOverGateway = null;
				mouseOverSwitch = null;
				mouseOverWds = null;
				mouseOverLocatorDevice = null;
				
				dataTipTimer = new Timer(1000, 1);
				dataTipTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onDataTipTimerComplete);
				dataTipTimer.start();
				
				if(event.hitData.chartItem.itemRenderer.name == Constants.FIXTURE_RENDERER)
				{
					mouseOverFixture = event.hitData.item;
					
					if(m_propertyMode != Constants.FLOORPLAN)
						return;
					
					if (mouseOverTimer != null) 
					{
						mouseOverTimer.stop();
						mouseOverTimer = null;
					}
					mouseOverTimer = new Timer(3000, 1);
					mouseOverTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onMouseOverTimerComplete);
					mouseOverTimer.start();
				}
				else if(event.hitData.chartItem.itemRenderer.name == Constants.GATEWAY_RENDERER)
				{
					mouseOverGateway = event.hitData.item;
					
					if(m_propertyMode != Constants.FLOORPLAN)
						return;
					
					if (mouseOverTimer != null) 
					{
						mouseOverTimer.stop();
						mouseOverTimer = null;
					}
					mouseOverTimer = new Timer(3000, 1);
					mouseOverTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onMouseOverTimerComplete);
					mouseOverTimer.start();
				}
				else if(event.hitData.chartItem.itemRenderer.name == Constants.SWITCH_RENDERER)
				{
					mouseOverSwitch = event.hitData.item;
				}
				else if(event.hitData.chartItem.itemRenderer.name == Constants.WDS_RENDERER)
				{
					mouseOverWds = event.hitData.item;
				}
				else if(event.hitData.chartItem.itemRenderer.name == Constants.LOCATOR_DEVICE_RENDERER)
				{
					mouseOverLocatorDevice = event.hitData.item;
				}
			}
			
			private function onMouseOverTimerComplete(event:TimerEvent):void
			{
				mouseOverTimer = null;
				if(mouseOverFixture)
				{
					fixuteRealtimeHttpService.url = Constants.serverurl + "fixture/op/realtime" + "/?ts=" + new Date().time;
					var fixtureXmlList:XML = XML("<fixtures><fixture><id>" + mouseOverFixture.id + "</id><name>" + mouseOverFixture.name + "</name></fixture></fixtures>");
					fixuteRealtimeHttpService.request = fixtureXmlList;
					fixuteRealtimeHttpService.send();
				}
				else if(mouseOverGateway)
				{
					gatewayRealtimeHttpService.url = Constants.serverurl + "gateway/op/realtime" + "/?ts=" + new Date().time;
					var gatewayXmlList:XML = XML("<gateways><gateway><id>" + mouseOverGateway.id + "</id></gateway></gateways>");
					gatewayRealtimeHttpService.request = gatewayXmlList;
					gatewayRealtimeHttpService.send();
				}
			}		
			
			public function createDate(str:String) : Date
			{
				var date:Date = new Date();
				date.setFullYear(str.slice(0,4));
				date.setMonth(str.slice(5,7));
				date.setMonth(date.getMonth() - 1);
				date.setDate(str.slice(8,10));
				date.setHours(str.slice(11,13));
				date.setMinutes(str.slice(14,16));
				date.setSeconds(str.slice(17,19));
				return date;
			}
			
			// Function needs to be public as it is called from fixture and gateway renderer
			public function getServerTime() : Date
			{
				var date:Date = new Date();
				
				// Get offset from GMT in milliseconds
				var offsetMilliseconds:Number = date.getTimezoneOffset() * 60 * 1000;
				var serverOffsetMilliseconds:Number = serverGMTOffset * 60 * 1000;
				
				// Convert the date to server time by adding the offsets from GMT
				date.setTime(date.getTime() + offsetMilliseconds + serverOffsetMilliseconds);
				
				return date;
			}
			
			private function onItemRollOut(event:MouseEvent) : void
			{
				hideDataTip();
				
				if(mouseOverTimer)
				{
					mouseOverTimer.stop();
					mouseOverTimer = null;
				}
				if(fixtureDetailsTimer)
				{
					fixtureDetailsTimer.stop();
					fixtureDetailsTimer = null;
				}
				mouseOverFixture = null;
				mouseOverGateway = null;
				mouseOverSwitch = null;
				mouseOverWds = null;
				mouseOverLocatorDevice = null;
				
				toolTipColor = "0xF8FBA9";
			}
			
			private function onDimmerMouseUp(event:FlexEvent) : void
			{
				manageDimmerControl(event.currentTarget.value.toString(), 'rel');
			}
			
			private function manageDimmerControl(dimmerValue:String, dimmingType:String) : void
			{
				if(selectedFixtures.length < 1)
				{
					FlexGlobals.topLevelApplication.showAlertMarquee(Constants.NO_FIXTURE_SELECTED_ERROR, true); 
					brightnessSlider.value = 0;
					return;
				}
				dimFixtureHttpService.url = Constants.serverurl + "fixture/op/dim/" + dimmingType + "/" + dimmerValue + "/60" + "/?ts=" + new Date().time;
				dimFixtureHttpService.request = createFixturesRequestXml();
				dimFixtureHttpService.send();
				brightnessSlider.value = 0;
			}
			
			private function createFixturesRequestXml() : XML
			{
				var requestXML:XML = <fixtures></fixtures>;
				var id:String;
				var name:String;
				
				for(var i:int=0; i<selectedFixtures.length; i++)
				{
					if(selectedFixtures[i] is PlotSeriesItem)
					{
						id = selectedFixtures[i].item.id;
						name = selectedFixtures[i].item.name;
					}
					else
					{
						id = selectedFixtures[i].id;
						name = selectedFixtures[i].name;
					}
					var xmlList:XMLList = XMLList("<fixture><id>" + id + "</id><name>" + name + "</name></fixture>");
					requestXML.appendChild(xmlList);
				}
				return requestXML;
			}
			
			private function onSceneDimmerMouseUp(event:FlexEvent):void{
				manageSceneDimmerControl(event.currentTarget.value.toString(), 'abs');
			}
			private function manageSceneDimmerControl(dimmerValue:String, dimmingType:String):void
			{
				if (reportsTableList.sceneTableGrid.selectedItems.length == 0) {
					FlexGlobals.topLevelApplication.showAlertMarquee(Constants.NO_FIXTURE_SELECTED_ERROR, true); 
					brightnessSlider.value = 0;
					return;
				}
				m_dimmerSceneVal = dimmerValue;

/*				dimFixtureHttpService.url = Constants.serverurl + "fixture/op/dim/" + dimmingType + "/" + dimmerValue + "/60" + "/?ts=" + new Date().time;
				// WE MAY NEED TO CREATE SEPARATE XML according selected Items in the Scene Datagrid, Currently taken from floorplan.
				dimFixtureHttpService.request = createFixturesRequestXml();
				dimFixtureHttpService.send();*/
				if (sceneDropDown.selectedIndex != -1) {
					saveSceneLightLevelBySwitchIdHttpService.url = Constants.serverurl + "scene/updatescenelevel?ts=" + new Date().time;
					saveSceneLightLevelBySwitchIdHttpService.request = getSceneLightLevelFixtureToUpdate(reportsTableList.sceneTableGrid.selectedItems);
					saveSceneLightLevelBySwitchIdHttpService.send();
				}
				brightnessSlider.value = 0;
			}
			
			/**
			 * Used to set the width and position of the search combobox 
			 **/
			private function comboOpenHandler(e:Event) : void
			{
				var comboBox:ComboBox = e.currentTarget as ComboBox;
				comboBox.dropDown.width = 120;
				comboBox.dropDown.x = comboBox.dropDown.x - comboBox.dropDown.width + comboBox.width;
			}
			
			/** 
			 * Function called when a new device is searched from the search combobox 
			 **/
			private function onSelectedItemChanged(event:IndexChangeEvent) : void
			{
				if(selectedItems.length > 0)
					removeSelection();
				
				if(!autoComplete.selectedItem)
					return;
				
				if(autoComplete.selectedItem.type == Constants.FIXTURE)
				{
					for(var l:int=0; l<commissionedFixtureData.length; l++)
					{
						if(commissionedFixtureData[l].id == autoComplete.selectedItem.id)
						{
							selectedItems.push(commissionedFixtureData[l]);
							selectedFixtures.addItem(commissionedFixtureData[l]);
							break;
						}
					}
				}
				else if(autoComplete.selectedItem.type == Constants.GATEWAY)
				{
					for(var m:int=0; m<commissionedGatewayData.length; m++)
					{
						if(commissionedGatewayData[m].id == autoComplete.selectedItem.id)
						{
							selectedItems.push(commissionedGatewayData[m]);
							selectedGateways.addItem(commissionedGatewayData[m]);
							break;
						}
					}
				}
				else if(autoComplete.selectedItem.type == Constants.SWITCH)
				{
					for(var n:int=0; n<switchesData.length; n++)
					{
						if(switchesData[n].id == autoComplete.selectedItem.id)
						{
							selectedItems.push(switchesData[n]);
							selectedSwitches.addItem(switchesData[n]);
							break;
						}
					}
				}
				else if(autoComplete.selectedItem.type == Constants.WDS)
				{
					for(var o:int=0; o<wdsData.length; o++)
					{
						if(wdsData[o].id == autoComplete.selectedItem.id)
						{
							selectedItems.push(wdsData[o]);
							selectedWds.addItem(wdsData[o]);
							break;
						}
					}
				}
				else if(autoComplete.selectedItem.type == Constants.LOCATORDEVICE)
				{
					for(var p:int=0; p<locatorDeviceData.length; p++)
					{
						if(locatorDeviceData[p].id == autoComplete.selectedItem.id)
						{
							selectedItems.push(locatorDeviceData[p]);
							selectedLocatorDevices.addItem(locatorDeviceData[p]);
							break;
						}
					}
				}
				
				applyFilters(selectedItems[0], "glowFilter"); // Only one item in selectedItems at this time. So removing the selection for the item at index 0.
				
				panTo(autoComplete.selectedItem.xaxis, autoComplete.selectedItem.yaxis);
				manageFloorPlanContextMenu();
				
				//dispatchEvent( new SearchEvent( SearchEvent.SEARCH_COMPLETE, autoComplete.selectedItem) );
			}
			protected function autoCompleteLabelToItemFunction(value:String):Object{ 
			  return null;// this will prevent typed in value from being added to the collection
			}
			private function changeLayer(event:IndexChangeEvent) : void
			{
				if(m_propertyMode == Constants.FLOORPLAN)
				{
					FixtureIconRenderer.rendererType = event.currentTarget.selectedItem.label;
					
					// Check when the data was last read from the server; if it's been more than 9 minutes then let's read it again
					var date:Date = new Date();
					var value:Number = ((date.time - fixtureDataReceivedAt.time)/1000)/60;
					
					// The number 9 is based on the following logic. The status icon turns grey when the 
					// last_connectivity is more than 15 minutes old. The fixture stats is received by
					// the server every 5 minutes. So if the floor plan receives the data say 4 minutes after
					// the stats were received for a fixture then there is a 4 minute window before the floor plan
					// refreshes the data (if the refresh happens after 15 minutes) when the fixture status will be grey.
					// To avoid this window, the refresh is done at 9 minutes instead of 15
					if(value > 9)
						refreshFloorPlan();
					
					commissionedFixtureData.filterFunction = null;
					commissionedFixtureData.refresh();
					
					if((event.currentTarget.selectedItem.label == Constants.FIXTURE_STATUS) ||
						(event.currentTarget.selectedItem.label == Constants.LIGHT_LEVEL) ||
						(event.currentTarget.selectedItem.label == Constants.AMBIENT_STATUS) ||
						(event.currentTarget.selectedItem.label == Constants.OCCUPANCY_STATUS) ||
						(event.currentTarget.selectedItem.label == Constants.TEMPERATURE_STATUS) ||
						(event.currentTarget.selectedItem.label == Constants.BULB_STATUS))
					{
						FixtureIconRenderer.imageStatus = event.currentTarget.selectedItem.label;
						
						//fixturePlotSeries.setStyle("radius", 8);
						showFilter = false;
					}
					else if((event.currentTarget.selectedItem.label == Constants.FIXTURE_NAME) ||
						(event.currentTarget.selectedItem.label == Constants.FIXTURE_MAC))
					{
						showFilter = false;
					}
					else if(event.currentTarget.selectedItem.label == Constants.FIXTURE_AREA)
					{
						if(m_propertyType == Constants.AREA)
						{
							showFilter = false;
						}
						else
						{
							createAreaFilterData();
						}					 
					}
					else if(event.currentTarget.selectedItem.label == Constants.FIXTURE_PROFILE)
					{
						createProfileFilterData();
					}
					else if(event.currentTarget.selectedItem.label == Constants.MOTION_GROUP ||  event.currentTarget.selectedItem.label == Constants.SWITCH_GROUP )
					{
						createGroupsFilterData(event.currentTarget.selectedItem.label);
					}
					fixturePlotSeries.invalidateDisplayList();
					//fixturePlotSeries.addEventListener(FlexEvent.UPDATE_COMPLETE, refreshFixturePlotSeries);
				}
				else if(m_propertyMode == Constants.REPORT)
				{
					if(event.currentTarget.selectedItem.label == Constants.ALL_FIXTURES)
					{
						fixturePlotSeries.dataProvider = commissionedFixtureData;
						for(var i:int = 0; i<fixturePlotSeries.dataProvider.length; i++)
						{
							var obj:Object = Object(fixturePlotSeries.getChildAt(i)).data.item;
							if (obj.bulblife < 25)
							{
								fixturePlotSeries.getChildAt(i).filters = [almostDeadGlowFilter];
							}						
							else if(obj.bulblife < 75 && obj.bulblife >= 25)
							{
								fixturePlotSeries.getChildAt(i).filters = [midlifeGlowFilter];
							}
							else
							{
								fixturePlotSeries.getChildAt(i).filters = [fullHealthGlowFilter];
							}
						}
					}
					else if(event.currentTarget.selectedItem.label == Constants.ALMOST_DEAD)
					{
						fixturePlotSeries.dataProvider = almostDeadFixtureData;
						for(var m:int = 0; m<fixturePlotSeries.dataProvider.length; m++)
						{
							fixturePlotSeries.getChildAt(m).filters = [almostDeadGlowFilter];
						}
					}
					else if(event.currentTarget.selectedItem.label == Constants.MIDLIFE_CRISIS)
					{
						fixturePlotSeries.dataProvider = midlifeFixtureData;
						for(var j:int = 0; j<fixturePlotSeries.dataProvider.length; j++)
						{
							fixturePlotSeries.getChildAt(j).filters = [midlifeGlowFilter];
						}
					}
				}
			}
			
			private function createAreaFilterData() : void
			{
				var localAreaData:ArrayCollection = new ArrayCollection(clone(areaData.source));
				var obj:Object = new Object();
				obj.name = "Select All";
				localAreaData.addItemAt(obj, 0);
				
				filterDropDown.dataProvider = null;
				filterDropDown.dataProvider = localAreaData;
				filterDropDown.labelField = "name";
				filterDropDown.prompt = "Select an Area";
				showFilter = true;
			}
			
			private function createProfileFilterData() : void
			{
				var localProfileData:ArrayCollection = new ArrayCollection(clone(profileData.source));
				var obj:Object = new Object();
				obj.name = "Select All";
				localProfileData.addItemAt(obj, 0);
				
				var customObj:Object = new Object();
				customObj.name = "Custom";
				localProfileData.addItem(customObj);
				
				filterDropDown.dataProvider = null;
				filterDropDown.dataProvider = localProfileData;
				filterDropDown.labelField = "name";
				filterDropDown.prompt = "Select a Profile";
				showFilter = true;
			}
			
			private function createGroupsFilterData(groupType:String) : void
			{
				var localGroupsData:ArrayCollection = new ArrayCollection(clone(groupsList.source));
				
				if(groupType == Constants.MOTION_GROUP){
					localGroupsData = new ArrayCollection(clone(motionGroupsList.source));
				}else{
					localGroupsData = new ArrayCollection(clone(switchGroupsList.source));
				}
			
				
				var obj:Object = new Object();
				obj.name = "Select All";
				localGroupsData.addItemAt(obj, 0);
				
				filterDropDown.dataProvider = null;
				filterDropDown.dataProvider = localGroupsData;
				filterDropDown.labelField = "name";
				if(groupType == Constants.MOTION_GROUP){
					filterDropDown.prompt = "Select a Motion Group";
				}else{
					filterDropDown.prompt = "Select a Switch Group";
				}
				showFilter = true;
			}
			
			private function filterChange(event:IndexChangeEvent) : void
			{
				if(event.currentTarget.selectedItem.name == "Select All")
				{
					commissionedFixtureData.filterFunction = null;
					commissionedFixtureData.refresh();
				}
				else
				{
					if(!layersDropDown.selectedItem)
						return;
					
					if(layersDropDown.selectedItem.label == Constants.FIXTURE_AREA)
						commissionedFixtureData.filterFunction = filterFixturesByArea;
					else if(layersDropDown.selectedItem.label == Constants.FIXTURE_PROFILE)
						commissionedFixtureData.filterFunction = filterFixturesByProfile;
					else if(layersDropDown.selectedItem.label == Constants.MOTION_GROUP || layersDropDown.selectedItem.label == Constants.SWITCH_GROUP)
					{
						fixturesByGroupIdHttpService.url = Constants.serverurl + "gemsgroupfixture/list/" + filterDropDown.selectedItem.id + "/?ts=" + new Date().time;;;
						fixturesByGroupIdHttpService.send();
					}
					else
						commissionedFixtureData.filterFunction = null;
					
					//fixturePlotSeries.invalidateDisplayList();
					commissionedFixtureData.refresh();
					
					//				fixturePlotSeries.validateDisplayList();
				}
			}
			
			private function filterFixturesByArea(item:Object) : Boolean
			{
				if(!filterDropDown.selectedItem)
					return true;
				
				if(item.area)
				{
					var searchString:String = filterDropDown.selectedItem.name.toLowerCase();
					var itemName:String = item.area.name.toLowerCase();
					return itemName.indexOf(searchString) > -1;
				}
				return false;
				
			}
			
			private function filterFixturesByProfile(item:Object) : Boolean
			{
				if(!filterDropDown.selectedItem)
					return true;
				
				if(item.currentprofile)
				{
					
					var currProfileItem:Object = filterDropDown.selectedItem;
					var searchString:String= filterDropDown.selectedItem.name.toLowerCase();
					var itemName:String = item.currentprofile.toLowerCase();
					if(currProfileItem!=null && currProfileItem.defaultProfile==true)
					{
						itemName=itemName+"_Default";
					}
					
					if(itemName.indexOf(searchString) > -1)
						return true;
					else
						return false;
				}
				return false;
				
			}
			
			private function filterFixturesByGroup(item:Object) : Boolean
			{
				if(!filterDropDown.selectedItem)
					return true;
				
				for(var i:int=0; i<fixturesByGroupList.length; i++)
				{
					if(fixturesByGroupList[i].id == item.id)
					{
						return true;
					}
				}
				return false;
			}
			
			private function filterFixturesBySwitch(item:Object) : Boolean
			{
				for(var i:int=0; i<fixturesBySwitchList.length; i++)
				{
					if(fixturesBySwitchList[i].id == item.id)
					{
						return true;
					}
				}
				return false;
			}			
			
			private function selectAll() : void
			{
				removeSelection();
				
				var series:Array = floorPlanChart.series;
				for (var i:int=0; i<series.length; i++) 
				{
					var seriesItems:Array = series[i].items;
					for(var j:int=0; j<seriesItems.length; j++)
					{
						seriesItems[j].itemRenderer.filters = [glowFilter];
						selectedItems.push(seriesItems[j]);
						
						if(seriesItems[j].itemRenderer.name == Constants.FIXTURE_RENDERER)
						{
							selectedFixtures.addItem(seriesItems[j]);
						}
						else if(seriesItems[j].itemRenderer.name == Constants.GATEWAY_RENDERER)
						{
							selectedGateways.addItem(seriesItems[j]);
						}
						else if(seriesItems[j].itemRenderer.name == Constants.SWITCH_RENDERER)
						{
							selectedSwitches.addItem(seriesItems[j]);
						} 
						else if(seriesItems[j].itemRenderer.name == Constants.WDS_RENDERER)
						{
							selectedWds.addItem(seriesItems[j]);
						}
						else if(seriesItems[j].itemRenderer.name == Constants.LOCATOR_DEVICE_RENDERER)
						{
							selectedLocatorDevices.addItem(seriesItems[j]);
						}
					}
				}
				
				manageFloorPlanContextMenu();
			}
			
			private function setGridPixels() : void
			{
				gridPixels = gridPixelsSlider.value;
				gridLines.invalidateDisplayList()
			}
			
			// Right click and place helper functions
			public function resetDevicePosition(): void
			{
				if (this.placeHoldersData != null)
					this.placeHoldersData.removeAll();
				this.placeHoldersData = null;
				devicePosition.x = 0;
				devicePosition.y = 0;
				if (commissionContextMenu != null) {
					var cmipos:ContextMenuItem = commissionContextMenu.customItems[0];
					cmipos.enabled = true;
				}
			}
			
			private function removeItemLabels() : void
			{
				// Remove all the labels from the background canvas
				for (var i:int = bgCanvas.numChildren - 1; i >= 0; i--) {
					if(bgCanvas.getChildAt(i) is Label)
						bgCanvas.removeChildAt(i);
				}
			}
			
			private function displayItemLabels() : void
			{
				var labelType:String = layersDropDown.selectedItem.label;
				// First remove the previous labels if any
				removeItemLabels();
				
				// Just return if the labels are not supposed to be displayed
				if(labelType != Constants.FIXTURE_NAME && labelType != Constants.FIXTURE_MAC && labelType != Constants.FIXTURE_AREA && 
				   labelType != Constants.MOTION_GROUP && labelType != Constants.SWITCH_GROUP && labelType != Constants.FIXTURE_PROFILE)
					return;
				
				// Display the label for each item in the fixturePlotSeries
				for(var i:int = 0; i < fixturePlotSeries.items.length; i++)
				{
					var myLabel:Label = new Label();
					if(labelType == Constants.FIXTURE_NAME)
						myLabel.text = fixturePlotSeries.items[i].item.name;
					else if(labelType == Constants.FIXTURE_MAC)
						myLabel.text = fixturePlotSeries.items[i].item.snapaddress;
					else if(labelType == Constants.FIXTURE_AREA)
					{
						if(fixturePlotSeries.items[i].item.area)
							myLabel.text = fixturePlotSeries.items[i].item.area.name;
						else
							continue;
					}
					else if(labelType == Constants.MOTION_GROUP || labelType == Constants.SWITCH_GROUP)
						myLabel.text = fixturePlotSeries.items[i].item.name;
					else if(labelType == Constants.FIXTURE_PROFILE)
						myLabel.text = fixturePlotSeries.items[i].item.currentprofile;
					
					myLabel.setStyle("fontSize", 10);
					myLabel.maxDisplayedLines = 1;
					myLabel.width = 70;
					myLabel.showTruncationTip = true;
					myLabel.setStyle("textAlign", "center");
					myLabel.setStyle("verticalAlign", "middle");
					myLabel.setStyle("backgroundColor", 0xFFFFFF);
					bgCanvas.addDataChild(myLabel, 0, 0, 0, 0, fixturePlotSeries.items[i].item.xaxis, fixturePlotSeries.items[i].item.yaxis - labelOffsetY);
				}
			}
			
			private function refreshFloorPlan() : void
			{
				getFloorPlanData();
				FlexGlobals.topLevelApplication.showAlertMarquee("Refreshing...", true);
				//fixturePlotSeries.addEventListener(FlexEvent.UPDATE_COMPLETE, refreshFixturePlotSeries);
				gatewayPlotSeries.addEventListener(FlexEvent.UPDATE_COMPLETE, refreshGatewayPlotSeries);
			}
			
			private function refreshFixturePlotSeries(event:FlexEvent) : void
			{
				if(fixturePlotSeries.items.length == 0)
				{
					// If there were some items displayed earlier and now they are getting filtered out then remove the earlier item labels if any
					removeItemLabels();
					return;
				}
				/*
				for(var l:int = 0; l<fixturePlotSeries.dataProvider.length; l++)
				{
					fixturePlotSeries.items[l].itemRenderer.onUpdateComplete();
				}
				*/
				// Now update the item labels
				//displayItemLabels();
			}
			
			private function refreshLocatorDevicePlotSeries(event:FlexEvent) : void
			{
				if(locatorDevicePlotSeries.items && locatorDevicePlotSeries.items.length == 0)
					return;
				
				if (locatorDevicePlotSeries.dataProvider) {
					for(var i:int = 0; i<locatorDevicePlotSeries.dataProvider.length; i++)
					{
						try {
							locatorDevicePlotSeries.items[i].itemRenderer.onUpdateComplete();
							
						}catch(e:Error) {
							trace(e.message);
						}
					}
				}
			}
			
			private function refreshGatewayPlotSeries(event:FlexEvent) : void
			{
				if(gatewayPlotSeries.items && gatewayPlotSeries.items.length == 0)
					return;
				
				if (gatewayPlotSeries.dataProvider) {
					for(var i:int = 0; i<gatewayPlotSeries.dataProvider.length; i++)
					{
						try {
							gatewayPlotSeries.items[i].itemRenderer.onUpdateComplete();
						}catch(e:Error) {
							trace(e.message);
						}
					}
				}
			}
			
			private function refreshSwitchPlotSeries(event:FlexEvent) : void
			{
				if(switchPlotSeries.items && switchPlotSeries.items.length == 0)
					return;
				// In SWITCH_MODE select the switch on the floorplan
				if(m_propertyMode == Constants.SWITCH_MODE && widgetSelectedTab == Constants.LOCATION_TAB && m_switchId != "")
				{
					for each(var switchObj:Object in switchesData)
					{
						if(switchObj.id == m_switchId)
						{
							// When switch is newly created it's co-ordinates are set to 0,0 so position the switch correctly
							if(switchObj.xaxis == 0 && switchObj.yaxis == 0)
							{
								switchObj.xaxis = int((panCanvas.horizontalScrollPosition) / (floorPlanChart.scaleX) + (12 * floorPlanChart.scaleX)) + 30;
								switchObj.yaxis = int(maxYaxis - (panCanvas.verticalScrollPosition) / (floorPlanChart.scaleY) - (12 * floorPlanChart.scaleY)) - 30;
								
								if(switchObj.yaxis < 0)
									switchObj.yaxis = switchObj.xaxis;
								
								var switchXmlList:XML = XML("<switches><switch><id>" + switchObj.id + "</id><xaxis>" + switchObj.xaxis + "</xaxis><yaxis>" + switchObj.yaxis + "</yaxis></switch></switches>");
								
								updateSwitchPositionHttpService.url = Constants.serverurl + "switch/du/updateposition" + "/?ts=" + new Date().time;
								updateSwitchPositionHttpService.request = switchXmlList;
								updateSwitchPositionHttpService.send();
							}

							selectedSwitches.addItem(switchObj);
							selectedItems.push(switchObj);
							applyFilters(switchObj, "glowFilter");
							switchPlotSeries.removeEventListener(FlexEvent.UPDATE_COMPLETE, refreshSwitchPlotSeries);
							break;
						}
					}					
				}
			}
			
			private function refreshWdsPlotSeries(event:FlexEvent) : void
			{
				if(wdsPlotSeries.items && wdsPlotSeries.items.length == 0)
					return;
				
				// In SWITCH_MODE select the switch on the floorplan
				if(m_propertyMode == Constants.SWITCH_MODE && widgetSelectedTab == Constants.LOCATION_TAB && m_wdsId != "")
				{
					for each(var wdsObj:Object in wdsData)
					{
						if(wdsObj.id == m_wdsId)
						{
							applyFilters(wdsObj, "glowFilter");
							break;
						}
					}					
				}
			}			

			/**
			 *  PRINT FUNCTIONALITY FOR PLOT CHART MODULE
			 */
			private var gridColumns:Array = new Array();
			
			private function saveAsPdf(e:MouseEvent):void
			{
				var printPDF:PDF = new PDF( Orientation.LANDSCAPE, Unit.MM, Size.LETTER );
				var printFileName :String ="";
				if(m_propertyType == Constants.FLOOR || m_propertyType == Constants.AREA)
				{
					var plotChart:PanComponent = null;
					plotChart = panCanvas;
					var height:Number = img.measuredHeight;
					var width:Number = img.measuredWidth;
					var factor:Number = this.GetFactorValue(height, width);
					var strLocation:String = "";
					if(m_propertyMode == Constants.FLOORPLAN)
					{
						strLocation = "FloorPlan";
						printFileName = "FloorPlan.pdf";
					}else
					{
						strLocation = "Outage Report ";
						printFileName = "Outage_Report.pdf";
					}
					printPDF.addPage();
					printPDF.setDisplayMode(Display.REAL); 
					printPDF.setFont(FontFamily.ARIAL, Style.NORMAL, 10);
					printPDF.textStyle(new RGBColor (0x000000));
					printPDF.addText(strLocation,120,20);
					printPDF.addImage(plotChart,5 , 24, plotChart.width/factor, plotChart.height/factor, ImageFormat.JPG,100,1,ResizeMode.FIT_TO_PAGE);
					
				}
				printPDF.setDisplayMode( Display.FULL_PAGE, Layout.SINGLE_PAGE);
				
				// PRINT DATA GRID
				if(m_propertyMode == Constants.REPORT)
				{
					var gridColumnName:GridColumn = new GridColumn("Fixture Name", "name", 40, Align.LEFT, Align.LEFT);
					gridColumns.push(gridColumnName);
					var gridColumnLocation:GridColumn = new GridColumn("Location", "location", 50, Align.LEFT, Align.LEFT);
					gridColumns.push(gridColumnLocation);
					var gridColumnOutageSice:GridColumn = new GridColumn("Outage Since", "outageSince", 50, Align.LEFT, Align.LEFT);
					gridColumns.push(gridColumnOutageSice);
					var gridColumnDesc:GridColumn = new GridColumn("Description", "description", 40, Align.LEFT, Align.LEFT);
					gridColumns.push(gridColumnDesc);
					printPDF.setDisplayMode( Display.REAL, Layout.SINGLE_PAGE );
					var grid:Grid = new Grid( commissionedFixtureData.toArray(), 600, 600, new RGBColor( 0xE6E6E6 ), new RGBColor( 0xE6E6E6 ), new RGBColor( 0 ), false, new RGBColor( 0x0 ),1, Joint.MITER );
					grid.columns = gridColumns;
					printPDF.addPage();
					printPDF.textStyle( new RGBColor(0), 1 );
					printPDF.setFont( FontFamily.ARIAL, Style.BOLD, 8 );
					printPDF.addGrid( grid, 5, 5 );
				}
				
				var fileRefObj:FileReference = new FileReference();
				fileRefObj.addEventListener(IOErrorEvent.IO_ERROR,ioErrorHander,false,0,true);
				var gridBytesArray:ByteArray = printPDF.save(Method.LOCAL);
				fileRefObj.save(gridBytesArray, printFileName);
			}
			private function ioErrorHander(e:IOErrorEvent):void
			{
				Alert.show("Error Occured while saving, Please close file if open any");
			}
			private function GetFactorValue(height:Number, width:Number):Number
			{	
				var idealWidth:Number = 275;
				var idealHeight:Number = 430;
				var factor:Number = 1;
				var tempWidth:Number = width;
				var tempHeight:Number = height;
				
				if(height <= idealHeight && width <= idealWidth)
				{
					return factor;
				}
				while(tempHeight > idealHeight || tempWidth > idealWidth)
				{
					tempWidth = width;
					tempHeight = height;
					factor = factor + 0.5;
					tempHeight = tempHeight / factor;
					tempWidth = tempWidth / factor;
				}
				return factor;
			}
			
			// PRINT FUNCTIONALITY FOR PLOT CHART MODULE - CODE END
			
			private function onDropDownOpen(event:Event) : void
			{
				(event.currentTarget.dropDown as UIComponent).maxHeight = UIComponent.DEFAULT_MAX_HEIGHT;
			}
			
			private function onAutoSelect() : void
			{
				if(selectedItems.length < 1)
				{
					FlexGlobals.topLevelApplication.showAlertMarquee(Constants.NO_FIXTURE_SELECTED_ERROR, true);
					return;
				}
				fixuteModeHttpService.url = Constants.serverurl + "fixture/op/mode/AUTO" + "/?ts=" + new Date().time;
				fixuteModeHttpService.request = createFixturesRequestXml();
				fixuteModeHttpService.send();
			}
			
			public function getSelectedDevices():void {
				if(m_propertyMode == Constants.REPORT)
					ExternalInterface.call("setSelectedDevices", reportsTableList.imageUpgradeFixtureGrid.selectedItems, reportsTableList.imageUpGradeGatewayGrid.selectedItems);
				else if(m_propertyMode == Constants.SWITCH_MODE)
					ExternalInterface.call("setSelectedDevices", reportsTableList.fixturesTableGrid.selectedItems);
				else if(m_propertyMode == Constants.GROUP_MODE || m_propertyMode == Constants.MOTION_BITS_GROUP_MODE)
					ExternalInterface.call("setSelectedDevices", reportsTableList.grpFixturesTableGrid.selectedItems);
				else if(m_propertyMode == Constants.IMAGE_UPGRADE)
				{
					var fixureListLength:Number= reportsTableList.imageUpgradeFixtureData.length;
					var gatewayListLength:Number= reportsTableList.imageUpgradeGatewayData.length;
					var wdsListLength:Number= reportsTableList.wdsData.length;
					var selectedFixtureId:Array = new Array();
					var selectedGatewayId:Array = new Array();
					var selectedWdsId:Array = new Array();
					for(var i:int=0; i<fixureListLength; i++)
					{
						selectedFixtureId.push(reportsTableList.imageUpgradeFixtureData.getItemAt(i));
					}
					for(var j:int=0; j<gatewayListLength; j++)
					{
						selectedGatewayId.push(reportsTableList.imageUpgradeGatewayData.getItemAt(j));
					}
					for(var k:int=0; k<wdsListLength; k++)
					{
						selectedWdsId.push(reportsTableList.wdsData.getItemAt(k));
					}
					ExternalInterface.call("setSelectedDevices", selectedFixtureId, selectedGatewayId, selectedWdsId);
				}
			}
			
			public function startImageUpgradeRefresh():void
			{
				var imgUpInitialTimer:Timer = new Timer(15000);
				imgUpInitialTimer.addEventListener(TimerEvent.TIMER, startImageUpgradeInitialTimer);
				imgUpInitialTimer.start();				
			}
			private function startImageUpgradeInitialTimer(event:TimerEvent):void{
				if(m_propertyMode==Constants.IMAGE_UPGRADE)
				{
					var txnObj:Object = new Object();
					txnObj.transactionId = TXN_ID;
					txnObj.propertyMode = m_propertyMode;
					txnObj.propertyType = m_propertyType;
					//Get the Image upgrade device status
					var currentDate:String = dateFormatter.format(new Date());
					getImageUpgradeDevicesStatus.url = Constants.serverurl + "imageupgrade/status" + "/" + currentDate;
					getImageUpgradeDevicesStatus.send(txnObj);
					//getImageUpgradeRunningStatus.url = Constants.serverurl + "imageupgrade/jobstatus" + "/?ts=" + new Date().time;
					//getImageUpgradeRunningStatus.send(txnObj);
				}
			}
			// These function are to select fixtures from FloorPlan to Fixture Grid in Image Upgrade View
			private function moveItemtoLeft():void
			{
				var fixSelIndicesArr:Array = []; 
			    var gwSelIndicesArr:Array = [];
				var wdsSelIndicesArr:Array = []; 

				var count:int = 0;
				
				// WDSs
				if(widgetSelectedTab == Constants.WDS_TAB)
				{
					for(var i:int=0; i<wdsPlotSeries.selectedItems.length; i++)
					{
						if(bMultipleGWs)
						{
							Alert.show("EWS cannot be associated with this switch as participating fixtures are associated with multiple gateways.", "Alert");
							return;
						}
						if(reportsTableList.wdsData.length != 0)
						{
							var isPresent:Boolean = false;
							for(var j:int=0; j < reportsTableList.wdsData.length; j++)
							{
								if(wdsPlotSeries.selectedItems[i].item.id == reportsTableList.wdsData[j].id)
								{
									wdsSelIndicesArr[count++] = j; 
									isPresent = true;
									break;
								}
							}
							if(!isPresent)
							{
								if(associatedGWId != -1 && associatedGWId != wdsPlotSeries.selectedItems[i].item.gatewayid)
								{
									Alert.show("EWS has to be associated with the same gateway as the fixtures", "Alert");
									continue;
								}
								if(bWDSAssociated && wdsGwId != wdsPlotSeries.selectedItems[i].item.gatewayid)
								{
									Alert.show("Failed to associate the EWS as another EWS bound to a different gateway is already associated", "Alert");
									continue;
								}
								reportsTableList.wdsData.addItem(wdsPlotSeries.selectedItems[i].item);
							}
						}
						else
						{
							if(associatedGWId != -1 && associatedGWId != wdsPlotSeries.selectedItems[i].item.gatewayid)
							{
								Alert.show("EWS has to be associated with the same gateway as the fixtures", "Alert");
								continue;
							}
							if(bWDSAssociated && wdsGwId != wdsPlotSeries.selectedItems[i].item.gatewayid)
							{
								Alert.show("Failed to associate the EWS as another EWS bound to a different gateway is already associated", "Alert");
								continue;
							}
							reportsTableList.wdsData.addItem(wdsPlotSeries.selectedItems[i].item);
						}
					}
					reportsTableList.wdsTableGrid.selectedIndices = wdsSelIndicesArr;
					
					// Call service to update the associated WDS list
					updateSwitchWDSsBySwitchIdHttpService.url = Constants.serverurl + "wds/updateSwitchWds/" + m_switchId + "?ts=" + new Date().time;
					updateSwitchWDSsBySwitchIdHttpService.request = getSwitchWDSListToUpdate(reportsTableList.wdsData);
					updateSwitchWDSsBySwitchIdHttpService.send();
					
					return;
				}
				
				for(var k:int=0; k<fixturePlotSeries.selectedItems.length; k++)
				{
					if(m_propertyMode == Constants.IMAGE_UPGRADE)
					{
						if(reportsTableList.imageUpgradeFixtureData.length!=0)
						{
							var isPresent1:Boolean = false;
							for(var l:int=0; l<reportsTableList.imageUpgradeFixtureData.length; l++)
							{
								if(fixturePlotSeries.selectedItems[k].item.id == reportsTableList.imageUpgradeFixtureData[l].id)
								{
									fixSelIndicesArr[count++] = l; 
									isPresent1 = true;
									break;
								}
							}
							if(!isPresent1)
							{
								reportsTableList.imageUpgradeFixtureData.addItem(fixturePlotSeries.selectedItems[k].item);
							}
						}
						else
						{
							reportsTableList.imageUpgradeFixtureData.addItem(fixturePlotSeries.selectedItems[k].item);
						}					
					}
					else if(m_propertyMode == Constants.SWITCH_MODE)
					{
						if(reportsTableList.switchFixtureData.length!=0)
						{
							var isPresent2:Boolean = false;
							for(var m:int=0; m<reportsTableList.switchFixtureData.length; m++)
							{
								if(fixturePlotSeries.selectedItems[k].item.id == reportsTableList.switchFixtureData[m].id)
								{
									fixSelIndicesArr[count++] = m; 
									isPresent2 = true;
									break;
								}
							}
							if(!isPresent2)
							{
								if(bWDSAssociated && wdsGwId != fixturePlotSeries.selectedItems[k].item.secgwid)
								{
									Alert.show("Only the fixtures associated with the same gateway as the EWS can be added to the switch", "Alert");
									return;
								}
								reportsTableList.switchFixtureData.addItem(fixturePlotSeries.selectedItems[k].item);
								
								if(m_fixtureVersion.toUpperCase() == "2.X" && associatedGWId != -1 && associatedGWId != fixturePlotSeries.selectedItems[k].item.secgwid)
								{
									bMultipleGWs = true;
									Alert.show("You will not be able to associate a EWS with this switch as participating fixtures are associated with multiple gateways.", "Alert");
								}
							}
						}
						else
						{
							if(bWDSAssociated && wdsGwId != fixturePlotSeries.selectedItems[k].item.secgwid)
							{
								Alert.show("Only the fixtures associated with the same gateway as the EWS can be added to the switch", "Alert");
								return;
							}
							reportsTableList.switchFixtureData.addItem(fixturePlotSeries.selectedItems[k].item);
							associatedGWId = fixturePlotSeries.selectedItems[k].item.secgwid;
						}
					}
					else if(m_propertyMode == Constants.GROUP_MODE || m_propertyMode == Constants.MOTION_BITS_GROUP_MODE)
					{
						if(reportsTableList.groupFixtureData.length != 0)
						{
							var isPresent3:Boolean = false;
							for(var n:int=0; n<reportsTableList.groupFixtureData.length; n++)
							{
								if(fixturePlotSeries.selectedItems[k].item.id == reportsTableList.groupFixtureData[n].id)
								{
									fixSelIndicesArr[count++] = n; 
									isPresent3 = true;
									break;
								}
							}
							if(!isPresent3)
							{
								if(m_propertyMode == Constants.GROUP_MODE && associatedGWId != -1 && associatedGWId != fixturePlotSeries.selectedItems[k].item.secgwid)
								{
									Alert.show("Only the fixtures associated with the same gateway/channel can be added to the group", "Alert");
									return;
								}
								reportsTableList.groupFixtureData.addItem(fixturePlotSeries.selectedItems[k].item);
							}
						}
						else
						{
							reportsTableList.groupFixtureData.addItem(fixturePlotSeries.selectedItems[k].item);
							if(m_propertyMode == Constants.GROUP_MODE)
								associatedGWId = fixturePlotSeries.selectedItems[k].item.secgwid;
						}
					}
				}
				
				if(m_propertyMode == Constants.SWITCH_MODE)
				{
					reportsTableList.imageUpgradeFixtureGrid.selectedIndices = fixSelIndicesArr;
					//UPdate the switch Fixture
					updateSwitchFixturesBySwitchIdHttpService.url = Constants.serverurl + "switch/updateSwitchFixtures/" + m_switchId + "?ts=" + new Date().time;
					updateSwitchFixturesBySwitchIdHttpService.request = getSwitchFixtureListToUpdate(reportsTableList.switchFixtureData);
					updateSwitchFixturesBySwitchIdHttpService.send();
				}

				if(m_propertyMode == Constants.GROUP_MODE)
				{
					//UPdate the group Fixture
					updateGroupFixturesByMGIDHttpService.url = Constants.serverurl + "motiongroup/updateGroupFixtures/" + m_groupId + "?ts=" + new Date().time;
					updateGroupFixturesByMGIDHttpService.request = getSwitchFixtureListToUpdate(reportsTableList.groupFixtureData);
					updateGroupFixturesByMGIDHttpService.send();
				}
				else if(m_propertyMode == Constants.MOTION_BITS_GROUP_MODE)
				{
					updateGroupFixturesByMGIDHttpService.url = Constants.serverurl + "motionbits/updateGroupFixtures/" + m_groupId + "?ts=" + new Date().time;
					updateGroupFixturesByMGIDHttpService.request = getSwitchFixtureListToUpdate(reportsTableList.groupFixtureData);
					updateGroupFixturesByMGIDHttpService.send();
				}

				//Gateways
				if(m_propertyMode == Constants.IMAGE_UPGRADE)
				{
					// Gateway
					count = 0;
					for(var x:int=0; x<gatewayPlotSeries.selectedItems.length; x++)
					{
						if(reportsTableList.imageUpgradeGatewayData.length != 0)
						{
							var isPresent4:Boolean = false;
							for(var y:int=0; y<reportsTableList.imageUpgradeGatewayData.length; y++)
							{
								if(gatewayPlotSeries.selectedItems[x].item.id == reportsTableList.imageUpgradeGatewayData[y].id)
								{
									gwSelIndicesArr[count++] = y; 
									isPresent4 = true;
									break;
								}
							}
							if(!isPresent4)
							{
								reportsTableList.imageUpgradeGatewayData.addItem(gatewayPlotSeries.selectedItems[x].item);
							}
						}else
						{
							reportsTableList.imageUpgradeGatewayData.addItem(gatewayPlotSeries.selectedItems[x].item);
						}
					}
					
					// WDS
					count = 0;
					for(var p:int=0; p<wdsPlotSeries.selectedItems.length; p++)
					{
						if(reportsTableList.wdsData.length == 4)
						{
							FlexGlobals.topLevelApplication.showAlertMarquee("Only 4 EWS switches can be associated with a virtual switch", true);
							break;
						}
						if(reportsTableList.wdsData.length != 0)
						{
							var isPresent5:Boolean = false;
							for(var q:int=0; q < reportsTableList.wdsData.length; q++)
							{
								if(wdsPlotSeries.selectedItems[i].item.id == reportsTableList.wdsData[q].id)
								{
									wdsSelIndicesArr[count++] = q; 
									isPresent5 = true;
									break;
								}
							}
							if(!isPresent5)
							{
								reportsTableList.wdsData.addItem(wdsPlotSeries.selectedItems[p].item);
							}
						}
						else
						{
							reportsTableList.wdsData.addItem(wdsPlotSeries.selectedItems[p].item);
						}
					}
				}
			}
			
			private function getSceneLightLevelFixtureToUpdate(selFixture:Array):XML {
				//<sceneLevels><sceneLevel><id></id><switchid>122</switchid><sceneid>86</sceneid><fixtureid>131</fixtureid><lightlevel>100</lightlevel></sceneLevel></sceneLevels>
				var requestXML:XML = <sceneLevels></sceneLevels>;
				var id:String;
				var sceneId:int = sceneDropDown.selectedItem.id;
				for(var i:int=0; i<selFixture.length; i++)
				{
					id = selFixture[i].id;
					var xmlList:XMLList = XMLList("<sceneLevel><switchid>"+ m_switchId+"</switchid><sceneid>"+sceneId+"</sceneid><fixtureid>" + id + "</fixtureid><lightlevel>"+m_dimmerSceneVal+"</lightlevel></sceneLevel>");
					requestXML.appendChild(xmlList);
				}
				return requestXML;
			}
			
			private function getSwitchFixtureListToUpdate(selFixture:ArrayCollection) : XML
			{
				var requestXML:XML = <fixtures></fixtures>;
				var id:String;
				var name:String;
				
				for(var i:int=0; i<selFixture.length; i++)
				{
					id = selFixture[i].id;
					name = selFixture[i].name;
					var xmlList:XMLList = XMLList("<fixture><id>" + id + "</id></fixture>");
					requestXML.appendChild(xmlList);
				}
				return requestXML;
			}

			private function getSwitchWDSListToUpdate(selWDS:ArrayCollection) : XML
			{
				var requestXML:XML = <wdss></wdss>;
				var id:String;
				var name:String;
				
				for(var i:int=0; i<selWDS.length; i++)
				{
					id = selWDS[i].id;
					name = selWDS[i].name;
					var xmlList:XMLList = XMLList("<wds><id>" + id + "</id></wds>");
					requestXML.appendChild(xmlList);
				}
				return requestXML;
			}
			
			private function moveItemtoRight():void
			{
				if(m_propertyMode == Constants.IMAGE_UPGRADE)
				{
					if (reportsTableList.reportTabNavigator.selectedIndex == 0) {
						var selArr:Array = reportsTableList.imageUpgradeFixtureGrid.selectedItems;
					
						if(selArr.length>0)
						{
							for(var j:Number=0; j<selArr.length; j++)
							{
								var oImgObj:Object = selArr[j];  
								var imgIdx:int = reportsTableList.imageUpgradeFixtureData.getItemIndex(oImgObj);   
								reportsTableList.imageUpgradeFixtureData.removeItemAt(imgIdx);
							}
						}
						reportsTableList.imageUpgradeFixtureGrid.selectedIndices=[];
					}
					else if (reportsTableList.reportTabNavigator.selectedIndex == 1){
						var selGwArr:Array = reportsTableList.imageUpGradeGatewayGrid.selectedItems;
					
						if(selGwArr.length>0)
						{
							for(var k:Number=0; k<selGwArr.length; k++)
							{
								var oGwObj:Object = selGwArr[k];  
								var gwImgIdx:int = reportsTableList.imageUpgradeGatewayData.getItemIndex(oGwObj);   
								reportsTableList.imageUpgradeGatewayData.removeItemAt(gwImgIdx);
							}
						}
						reportsTableList.imageUpGradeGatewayGrid.selectedIndices=[];
					} 
					else {
						// WDS
						var seleWDSArr:Array = reportsTableList.imageUpgradeWDSGrid.selectedItems;
						
						if(seleWDSArr.length>0)
						{
							for(var l:Number=0; l<seleWDSArr.length; l++)
							{
								var wds:Object = seleWDSArr[l];  
								var wdsidx:int = reportsTableList.wdsData.getItemIndex(wds);   
								reportsTableList.wdsData.removeItemAt(wdsidx);
							}
						}
						reportsTableList.imageUpgradeWDSGrid.selectedIndices=[];
					}
				}
				else if(m_propertyMode == Constants.SWITCH_MODE)
				{
					if(widgetSelectedTab == Constants.WDS_TAB)
					{
						//Remove the selected Item from Datagrid
						var seleWDSArr1:Array = reportsTableList.wdsTableGrid.selectedItems;
						
						if(seleWDSArr1.length>0)
						{
							for(var m:Number=0; m<seleWDSArr1.length; m++)
							{
								var wds1:Object = seleWDSArr1[m];  
								var wdsidx1:int = reportsTableList.wdsData.getItemIndex(wds1);   
								reportsTableList.wdsData.removeItemAt(wdsidx1);
								//Alert.show(item.id + item.name );
							}
						}
						reportsTableList.wdsTableGrid.selectedIndices=[];

						//Remove the switch Fixture
						updateSwitchWDSsBySwitchIdHttpService.url = Constants.serverurl + "wds/updateSwitchWds/" + m_switchId + "?ts=" + new Date().time;
						updateSwitchWDSsBySwitchIdHttpService.request = getSwitchWDSListToUpdate(reportsTableList.wdsData);
						updateSwitchWDSsBySwitchIdHttpService.send();
					}
					else if(widgetSelectedTab == Constants.FIXTURE_TAB)
					{
						//Remove the selected Item from Datagrid
						var seleItemsArr:Array = reportsTableList.fixturesTableGrid.selectedItems;
						if(seleItemsArr.length>0)
						{
							for(var i:Number=0;i<seleItemsArr.length;i++)
							{
								var item:Object = seleItemsArr[i];  
								var idx:int = reportsTableList.switchFixtureData.getItemIndex(item);   
								reportsTableList.switchFixtureData.removeItemAt(idx);
								//Alert.show(item.id + item.name );
							}
						}
						reportsTableList.fixturesTableGrid.selectedIndices=[];
						//Remove the switch Fixture
						updateSwitchFixturesBySwitchIdHttpService.url = Constants.serverurl + "switch/updateSwitchFixtures/" + m_switchId + "?ts=" + new Date().time;
						updateSwitchFixturesBySwitchIdHttpService.request = getSwitchFixtureListToUpdate(reportsTableList.switchFixtureData);
						updateSwitchFixturesBySwitchIdHttpService.send();
					}
				}
				else if(m_propertyMode == Constants.GROUP_MODE || m_propertyMode == Constants.MOTION_BITS_GROUP_MODE)
				{
					//Remove the selected Item from Datagrid
					var seleItemsArr1:Array = reportsTableList.grpFixturesTableGrid.selectedItems;
					
					if(seleItemsArr1.length>0)
					{
						for(var x:Number=0; x<seleItemsArr1.length; x++)
						{
							var item1:Object = seleItemsArr1[x];  
							var idx1:int = reportsTableList.groupFixtureData.getItemIndex(item1);   
							reportsTableList.groupFixtureData.removeItemAt(idx1);
							//Alert.show(item.id + item.name );
						}
					}
					reportsTableList.grpFixturesTableGrid.selectedIndices=[];
					//Remove the group Fixture
					updateGroupFixturesByMGIDHttpService.url = Constants.serverurl + "motiongroup/updateGroupFixtures/" + m_groupId + "?ts=" + new Date().time;
					updateGroupFixturesByMGIDHttpService.request = getSwitchFixtureListToUpdate(reportsTableList.groupFixtureData);
					updateGroupFixturesByMGIDHttpService.send();
				}
				removeSelection();
			}
			
			private function deleteCurrentScene(event:CloseEvent) : void
			{
				if(event.detail == mx.controls.Alert.NO)
					return;
				
				var currentSceneObj:Object;
				if(sceneDropDown)
					currentSceneObj  = sceneDropDown.selectedItem;
				if(currentSceneObj)
				{
					deleteSceneBySwitchIdHttpService.url = Constants.serverurl + "scene/delete/" + currentSceneObj.id + "?ts=" + new Date().time;
					deleteSceneBySwitchIdHttpService.send();
				}
			}
			
			private function onDeleteScene(event:MouseEvent) : void
			{
				var currentSceneObj:Object;
				if(sceneDropDown)
					currentSceneObj  = sceneDropDown.selectedItem;
				if(currentSceneObj)
				{
					var strAlert:String = "Are you sure you want to delete scene: " + currentSceneObj.name + "?";
					Alert.show(strAlert, "Confirm delete", mx.controls.Alert.YES | mx.controls.Alert.NO, this, deleteCurrentScene, null, mx.controls.Alert.YES);
				}
			}

			private function onApplyScene(event:MouseEvent) : void
			{
				if(bSceneTestInProgress == false)
				{
					bSceneTestInProgress = true;
					// Change the button label
					event.currentTarget.label="End test";
				}
				else
				{
					bSceneTestInProgress = false;
					// change the label an return
					event.currentTarget.label="Test scene";
					return;
				}
				if (sceneDropDown.selectedIndex != -1) 
				{
					applySceneBySwitchIdHttpService.url = Constants.serverurl + "switch/op/dim/switch/" + m_switchId + "/scene/" + sceneDropDown.selectedItem.id + "/102/10?ts=" + new Date().time;
					applySceneBySwitchIdHttpService.send();
				}
			}

			private function onEditScene(event:MouseEvent) : void
			{
				m_bCreateScene = false;
				var win : CreateSceneView = new CreateSceneView();
				PopUpManager.addPopUp(win,this,true);
				win.sceneValue.text = sceneDropDown.selectedItem.name;
				PopUpManager.centerPopUp(win);
			}
			
			private function onSceneIdArrowUp(event:MouseEvent) : void
			{
				var strId:String = sceneId.text;
				var id:int = parseInt(strId);
				id++;
				if(id > sceneDropDownArray.length)
				{
					sceneArrowUp.enabled = false;
					id = sceneDropDownArray.length;
					return;
				}
				sceneId.text = id.toString();
				
				for(var n:int = 0; n < sceneDropDownArray.length; n++)
				{
					sceneDropDownArray[n].sceneOrder = sceneDropDownArray[n].sceneOrder + 1;
					
					if(sceneDropDownArray[n].sceneOrder > sceneDropDownArray.length + 1)
						sceneDropDownArray[n].sceneOrder = 2;
				}
				nSceneIndex = sceneDropDown.selectedIndex + 1;
				saveAllScenes();
			}
			
			private function onSceneIdArrowDown(event:MouseEvent) : void
			{
				var strId:String = sceneId.text;
				var id:int = parseInt(strId);
				id--;
				if(id < 1)
				{
					sceneArrowDown.enabled = false;
					id = 1;
					return;
				}
				sceneId.text = id.toString();

				for(var n:int = 0; n < sceneDropDownArray.length; n++)
				{
					sceneDropDownArray[n].sceneOrder = sceneDropDownArray[n].sceneOrder - 1;
					
					if(sceneDropDownArray[n].sceneOrder < 2)
						sceneDropDownArray[n].sceneOrder = sceneDropDownArray.length + 1;
				}
				
				nSceneIndex = sceneDropDown.selectedIndex - 1;
				saveAllScenes();
			}
			
			private function saveAllScenes() : void
			{
				var requestXML:XML = <scenes></scenes>;
				var id:String;
				var name:String;
				var order:String;
				
				for(var i:int=0; i<sceneDropDownArray.length; i++)
				{
					id = sceneDropDownArray[i].id;
					name = sceneDropDownArray[i].name;
					order = sceneDropDownArray[i].sceneOrder;
					
					var xmlList:XMLList = XMLList("<scene><switchid>"+ m_switchId+"</switchid><id>"+id+"</id><name>" + name + "</name><sceneOrder>" + order +"</sceneOrder></scene>");
					requestXML.appendChild(xmlList);
				}

				saveSceneListHttpService.url = Constants.serverurl + "scene/savescenelist?ts=" + new Date().time;
				saveSceneListHttpService.request = requestXML;
				saveSceneListHttpService.send();
			}
			
			private function openSceneDialog():void
			{
				if(sceneDropDownArray.length == 6)
				{
					FlexGlobals.topLevelApplication.showAlertMarquee("Only 6 scenes can be created for a virtual switch", true);
					return;
				}
				m_bCreateScene = true;
				var win : CreateSceneView = new CreateSceneView();
				PopUpManager.addPopUp(win,this,true);
				PopUpManager.centerPopUp(win);
			}
			
			public function saveScene(sceneName:String):void{
				var sceneXML:String;
				for(var i:int = 0; i < sceneDropDownArray.length; i++)
				{
					if(sceneName == sceneDropDownArray[i].name)
					{
						FlexGlobals.topLevelApplication.showAlertMarquee("Scene with the same name already exists.", true);
						return;
					}
				}
				sceneName = encodeURIComponent(sceneName);
				if(m_bCreateScene)
				{
					sceneXML = "<scene><name>"+sceneName+"</name><switchid>"+m_switchId+"</switchid></scene>";
				}
				else
					sceneXML = "<scene><name>"+sceneName+"</name><switchid>"+m_switchId+"</switchid><id>"+sceneDropDown.selectedItem.id+"</id><sceneOrder>"+sceneDropDown.selectedItem.sceneOrder+"</sceneOrder></scene>";
					
				addSceneBySwitchIdHttpService.url = Constants.serverurl + "scene/savescene?ts=" + new Date().time;
				addSceneBySwitchIdHttpService.request = sceneXML;
				addSceneBySwitchIdHttpService.send();
			}
			
			private function onSceneDropDownChange(event:Event):void
			{
				trace("onSceneDropDownChange called");
				
				var currentSceneObj:Object = (event.currentTarget as DropDownList).selectedItem;

				if(currentSceneObj)
				{
					sceneId.text = String(currentSceneObj.sceneOrder - 1);
					if(sceneId.text == "1")
					{
						sceneArrowDown.enabled = false;
						sceneArrowUp.enabled = true;
					}
					else if(sceneId.text == String(sceneDropDownArray.length))
					{
						sceneArrowDown.enabled = true;
						sceneArrowUp.enabled = false;
					}
					else
					{
						sceneArrowDown.enabled = true;
						sceneArrowUp.enabled = true;
					}
					getSceneLevelBySwitchIdHttpService.url = Constants.serverurl + "scene/list/scenelevel/sid/"+currentSceneObj.id+"?ts=" + new Date().time;
					getSceneLevelBySwitchIdHttpService.send();
					
					if(bSceneTestInProgress)
					{
						applySceneBySwitchIdHttpService.url = Constants.serverurl + "switch/op/dim/switch/" + m_switchId + "/scene/" + currentSceneObj.id + "/102/10?ts=" + new Date().time;
						applySceneBySwitchIdHttpService.send();
					}
				}
			}
			
			protected function AddWDSHandler(event:MouseEvent):void
			{
				ExternalInterface.call("showWdsCommissioningIdentifyWindow", m_switchId);
			}
			
			private function getProfileDataById(profileId:Number):Object
			{
				if(profileData!=null && profileData.length>0)
				{
					var profile:Object = new Object();
					for each(var profileObj:Object in profileData)
					{
						if(profileObj.id == profileId)
						{
							profile.id = profileObj.id;
							profile.name = profileObj.name;
							profile.defaultProfile = profileObj.defaultProfile;
							profile.profileNo = profileObj.profileNo;
							break;
						}
					}
					return profile;
				}
				return null;
			}
			
			private function setDefaultProfileName(currentProfileName:String):String{
				var currProfile :String = currentProfileName;
				var defaultStr :String = "Default";
				if(currProfile.toUpperCase()!= defaultStr.toUpperCase())
				{
					currentProfileName=currProfile+"_Default";
				}
				return currentProfileName;
			}
		]]>
	</fx:Script>
	
	<!-- Top bar with filters, brightness bar, etc-->
	<mx:ViewStack id="toolbarViewStack" width="100%" includeInLayout="{showToolbarViewStack}" visible="{showToolbarViewStack}" verticalGap="0">
		<mx:HBox width="100%"  horizontalAlign="center" verticalAlign="middle">
			<mx:HBox id="viewFilterBox" width="100%" includeInLayout="{showViewFilterBox}" visible="{showViewFilterBox}"
					 verticalAlign="middle" 
					 paddingLeft="10" paddingRight="10">
				<mx:Text id="viewLabel" text="{Constants.VIEW}" includeInLayout="{showViewLabel}" visible="{showViewLabel}" 
						 color="0xd42720" fontWeight="bold"/>
				<s:DropDownList id="layersDropDown" width="150" includeInLayout="{showLayersDropDown}" visible="{showLayersDropDown}"
								color="0xd42720"
								change="changeLayer(event)"
								open="onDropDownOpen(event)" skinClass="com.enlightedinc.components.skin.VariableRowDropDownList">
				</s:DropDownList>
				<s:DropDownList id="filterDropDown" width="150"
								color="0xd42720"
								change="filterChange(event)"
								visible="{showFilter}" includeInLayout="{showFilter}" skinClass="com.enlightedinc.components.skin.VariableRowDropDownList"/>
				<mx:Text text="{Constants.FIND}"
						 color="0xd42720" fontWeight="bold"
						 visible="{showSearch}" includeInLayout="{showSearch}"/>
				<s:ComboBox id="autoComplete" 
							width="120" height="25"
							dataProvider="{searchData}"
							open="comboOpenHandler(event)"
							labelField="name"
							labelToItemFunction="autoCompleteLabelToItemFunction"
							change="onSelectedItemChanged(event)"
							visible="{showSearch}" includeInLayout="{showSearch}"/>
				<mx:HBox horizontalAlign="center" verticalAlign="middle"
						 visible="{floorplanMode}" includeInLayout="{floorplanMode}">
					<mx:Text text="{Constants.OVERRIDE_LIGHT_LEVEL}"
							 color="0xd42720" fontWeight="bold"/>
					<s:Button label="{Constants.OFF}" color="0xd42720" 
							  click="manageDimmerControl('0', 'abs')"
							  toolTip="{Constants.OFF}" width="45"/>			
					<components:CustomHSlider id="brightnessSlider"
											  minimum="-99" maximum="99"
											  snapInterval="5"
											  changeEnd="onDimmerMouseUp(event)"
											  skinClass="{CustomHSliderSkin}"/>
					<s:Button label="{Constants.ON}" color="0xd42720"
							  click="manageDimmerControl('100', 'abs')"
							  toolTip="{Constants.FULL_ON}" width="40"/>
					<s:Button label="{Constants.AUTO_LIGHT_LEVEL}" color="0xd42720"
							  click="onAutoSelect()"/>
				</mx:HBox>
				
			</mx:HBox>
			
			<mx:Spacer width="100%"/>
			
			<mx:HBox paddingRight="10" horizontalAlign="center" verticalAlign="middle">
				<s:Button id="saveAsPdfButton" name="{Constants.SAVE_AS_PDF}"
						  label="{Constants.SAVE_AS_PDF}" 
						  toolTip="{Constants.SAVE_AS_PDF}"
						  click="saveAsPdf(event)"
						  color="0xd42720"
						  visible="{showSaveAsPdfButton}" includeInLayout="{showSaveAsPdfButton}"/>
		</mx:HBox>
		</mx:HBox>
		<mx:HBox width="100%">
			<mx:VBox>
				<mx:HBox paddingRight="10" horizontalAlign="center" verticalAlign="middle" paddingTop="3" paddingLeft="15">
					<s:Button label="Create Scene" id="createScene" click="openSceneDialog()"/>
					<components:GroupBox backgroundColor="0xFFFFFF" label="Existing scenes" skinClass="com.enlightedinc.components.skin.GroupBoxLegendSkin">
						<mx:VBox>
							<mx:HBox paddingLeft="10" horizontalAlign="center" verticalAlign="middle">
								<mx:Text id="sceneLabel" text="Name :" color="0xd42720" fontWeight="bold"/>
								<s:DropDownList id="sceneDropDown" width="150" 
												color="0xd42720" dataProvider="{sceneDropDownArray}"
												labelField="name" valueCommit="onSceneDropDownChange(event)"
												change="onSceneDropDownChange(event)" skinClass="com.enlightedinc.components.skin.VariableRowDropDownList">
								</s:DropDownList>
								<mx:Text id="sceneIdLabel" text="Order :" color="0xd42720" fontWeight="bold"/>
								<s:Label id="sceneId" text="" textAlign="center"/>
								<mx:VBox verticalAlign="middle">
									<mx:Image id="sceneArrowUp" buttonMode="true" source="{Images.UpArrow}" click="onSceneIdArrowUp(event);"/>
									<mx:Image id="sceneArrowDown" buttonMode="true" source="{Images.DownArrow}" click="onSceneIdArrowDown(event);"/>
								</mx:VBox>
							</mx:HBox>
							<mx:HBox paddingLeft="10">
								<s:Button label="Delete Scene" id="deleteScene" click="onDeleteScene(event);" />
								<s:Button label="Edit Scene Name" id="editScene" click="onEditScene(event);"/>
								<s:Button label="Test Scene" id="applyScene" click="onApplyScene(event);"/>
							</mx:HBox>
						</mx:VBox>
					</components:GroupBox>
					<mx:VBox horizontalAlign="center">
						<mx:HBox>
							<mx:Text text="Adjust light level for selected fixture(s)"
									 color="0xd42720" fontWeight="bold" textAlign="center"/>
						</mx:HBox>
						<mx:HBox>
							<s:Button label="{Constants.OFF}" color="0xd42720" 
									  click="manageSceneDimmerControl('0', 'abs')"
									  toolTip="{Constants.OFF}" width="45"/>			
							<s:HSlider id="sceneSlider"
									   minimum="0" maximum="100"
									   snapInterval="5"
									   changeEnd="onSceneDimmerMouseUp(event)"/>
							<s:Button label="{Constants.ON}" color="0xd42720"
									  click="manageSceneDimmerControl('100', 'abs')"
									  toolTip="{Constants.FULL_ON}" width="40"/>
						</mx:HBox>
					</mx:VBox>
				</mx:HBox>
			</mx:VBox>
		</mx:HBox>
		<mx:HBox paddingLeft="10">
			<s:Button click="AddWDSHandler(event)" label="Add EWS" visible="{!bMultipleGWs}" />
		</mx:HBox>
		<mx:HBox textAlign="center" horizontalAlign="center" verticalAlign="middle">
			<s:Label text="Image upgrade in progress" fontSize="14" fontWeight="bold"/>
		</mx:HBox>
	</mx:ViewStack>
	
	<mx:HBox width="100%" horizontalAlign="right">
		<mx:Box styleName="pinBox"
				visible="{!slidingToolsWindow.visible}">
			<mx:Image id="pinImage"
					  source="{Images.LeftArrow}"
					  toolTip="{Constants.PIN_TOOLS_WINDOW}"
					  buttonMode="true"
					  click="pinOrUnpin(event)"/>
		</mx:Box>
	</mx:HBox>
	<mx:HBox id="mainContainer" width="100%" height="100%" includeInLayout="{showMainContainer}" visible="{showMainContainer}"
			 horizontalGap="0"
			 keyUp="onKeyUp(event)">
		<mx:HDividedBox id="hdivbox" width="100%" height="100%">
		<mx:VBox id="reportsTable" width="250" height="100%" visible="{reportVisibilityFlag}" includeInLayout="{reportVisibilityFlag}">
			<components:ReportTable id="reportsTableList" width="100%" height="100%"/>
		</mx:VBox>
		<mx:HBox width="100%" height="100%" id="fpwrapper" includeInLayout="{showfpwrapper}" visible="{showfpwrapper}">
		<mx:VBox id="selectionToolsWindow" height="100%" visible="{showSelectionToolsWindow}" includeInLayout="{showSelectionToolsWindow}" 
				verticalAlign="middle">
			<mx:Image id="moveLeft" 
					  source="{Images.LeftArrowColor}" 
					  buttonMode="true" mouseChildren="false"
					  click="moveItemtoLeft()"/>
			<mx:Image id="moveRight" 
					  source="{Images.RightArrowColor}" 
					  buttonMode="true" mouseChildren="false"
					  click="moveItemtoRight()"/>
		
		</mx:VBox>
		<mx:HBox horizontalGap="0" height="100%" width="100%" id="floorPlanOuterContainer" includeInLayout="{showFloorPlanOuterContainer}" visible="{showFloorPlanOuterContainer}" >
			<components:PanComponent id="panCanvas" 
									 width="100%" height="100%"
									 doubleClickEnabled="true"
									 doubleClick="zoom(event, 'doubleClick')"
									 mouseWheel="zoom(event, 'mouseWheel')" 
									 mouseOver="setCursor(event)" mouseOut="panCanvas.cursorManager.removeAllCursors()">
				<mx:Image id="img" 
						  httpStatus="imgHttpStatus(event)" 
						  complete="loadComplete(event)"/>
				<mx:PlotChart id="floorPlanChart"
							  selectionMode="multiple"
							  showDataTips="false"
							  itemRollOver="onItemRollOver(event)" itemRollOut="onItemRollOut(event)">
					<mx:backgroundElements>
						<mx:GridLines id="gridLines" gridDirection="{gridDirection}">
							<mx:horizontalStroke>
								<mx:SolidColorStroke color="0xCCCCCC" weight="1"/>
							</mx:horizontalStroke>
							<mx:verticalStroke>
								<mx:SolidColorStroke color="0xCCCCCC" weight="1"/>
							</mx:verticalStroke>
						</mx:GridLines>
						<mx:CartesianDataCanvas id="bgCanvas" includeInRanges="true"/>
					</mx:backgroundElements>
					<mx:horizontalAxisRenderers>
						<mx:AxisRenderer axis="{haxis}" showLabels="false" showLine="false" tickLength="0"/>
					</mx:horizontalAxisRenderers>
					<mx:verticalAxisRenderers>
						<mx:AxisRenderer axis="{vaxis}" showLabels="false" showLine="false" tickLength="0"/>
					</mx:verticalAxisRenderers>
					<mx:horizontalAxis>
						<mx:LinearAxis id="haxis" maximum="{maxXaxis}" minimum="0" interval="{gridPixels}"/>
					</mx:horizontalAxis>
					<mx:verticalAxis>
						<mx:LinearAxis id="vaxis" maximum="{maxYaxis}" minimum="0" interval="{gridPixels}"/>
					</mx:verticalAxis>
					<mx:series>
						<mx:PlotSeries id="fixturePlotSeries"
									   dataProvider="{commissionedFixtureData}"
									   xField="xaxis" yField="yaxis"
									   displayName="Floor Map"
									   selectable="true">
							<mx:itemRenderer>
								<fx:Component>
									<renderers:FixtureIconRenderer/>
								</fx:Component>
							</mx:itemRenderer>
						</mx:PlotSeries>
						
						<mx:PlotSeries id="gatewayPlotSeries"
									   dataProvider="{commissionedGatewayData}"
									   xField="xaxis" yField="yaxis"
									   selectable="true">
							<mx:itemRenderer>
								<fx:Component>
									<renderers:GatewayIconRenderer/>
								</fx:Component>
							</mx:itemRenderer>
						</mx:PlotSeries>
						<mx:PlotSeries id="switchPlotSeries"
									   dataProvider="{switchesData}"
									   xField="xaxis" yField="yaxis"
									   selectable="true">
							<mx:itemRenderer>
								<fx:Component>
									<renderers:SwitchItemRenderer/>
								</fx:Component>
							</mx:itemRenderer>
						</mx:PlotSeries>
						<mx:PlotSeries id="wdsPlotSeries"
						   dataProvider="{wdsData}"
						   xField="xaxis" yField="yaxis"
						   selectable="true">
							<mx:itemRenderer>
								<fx:Component>
									<renderers:WdsIconRenderer/>
								</fx:Component>
							</mx:itemRenderer>
						</mx:PlotSeries>
						<mx:PlotSeries id="locatorDevicePlotSeries"
									   dataProvider="{locatorDeviceData}"
									   xField="xaxis" yField="yaxis"
									   selectable="true">
							<mx:itemRenderer>
								<fx:Component>
									<renderers:LocatorDeviceItemRenderer/>
								</fx:Component>
							</mx:itemRenderer>
						</mx:PlotSeries>
						<mx:PlotSeries id="placeHoldersSeries" 
									   dataProvider="{this.placeHoldersData}" 
									   xField="xaxis" yField="yaxis" 
									   stroke="{s2}" 
									   fills="{[sc1,sc2,sc3]}" 
									   selectable="false">
						</mx:PlotSeries>
						
					</mx:series>
				</mx:PlotChart>
			</components:PanComponent>
			
			<!-- Tools Window holiding pin, unpin, panning mode, multiple selection mode, heat map, slider, etc-->
			<mx:VBox id="slidingToolsWindow" height="100%"
					 styleName="slidingToolsWindow"
					 visible="{pinToolsWindow}" includeInLayout="{pinToolsWindow}"
					 showEffect="{wipeleft}" hideEffect="{wiperight}">
				<mx:Box width="100%" styleName="pinBox">
					<mx:Image id="pinOrUnpinImage"
							  source="{Images.RightArrow}"
							  toolTip="{Constants.UNPIN_TOOLS_WINDOW}"
							  buttonMode="true"
							  click="pinOrUnpin(event)"/>
				</mx:Box>
				
				<mx:HBox width="100%"
						 horizontalAlign="center">
					<mx:Image id="multipleSelectionImage" 
							  source="{Images.MultipleSelectionEnabled}" 
							  buttonMode="true" mouseChildren="false"
							  click="onMultipleSelectionImageClick(event)"/>
					<mx:Image id="panSelectionImage" 
							  source="{Images.PanSelection}" 
							  buttonMode="true" mouseChildren="false"
							  click="onPanImageClick(event)"/>
					<mx:Image id="fitToScreenImage" 
							  source="{Images.FitToScreen}" 
							  buttonMode="true" mouseChildren="false"
							  click="zoom(event, 'originalSize')"/>
					<mx:Image id="refreshImage" 
							  source="{Images.Refresh}" 
							  buttonMode="true" mouseChildren="false"
							  click="refreshFloorPlan()"/>
				</mx:HBox>
				
				<mx:Text text="{Constants.ZOOM}"/>
				
				<components:CustomHSlider
					id="slider"
					minimum="{minSliderValue}"
					maximum="300"
					value="{minSliderValue}"
					snapInterval="5"
					liveDragging="true"
					change="zoomHandler()"/>
				
				<mx:HRule width="100%"
						  visible="{floorplanMode}" includeInLayout="{floorplanMode}"/>
				
				<mx:Box paddingLeft="3">
					<s:CheckBox id="lockDragDrop" 
								label="Lock Drag Drop"
								width="115"
								selected="true"
								change="onLockDragDropChange(event)"
								visible="{showLockDragDrop}" includeInLayout="{showLockDragDrop}"/>
					
					<s:CheckBox id="showGridCB" 
								label="Show Grid"
								width="115"
								selected="false"
								change="selectUnselectSnapToGrid(event)"
								visible="{showGridOptions}" includeInLayout="{showGridOptions}"/>
				</mx:Box>
				
				<components:CustomHSlider id="gridPixelsSlider"
										  enabled="false"
										  minimum="2" maximum="100"
										  value="16" snapInterval="1"
										  liveDragging="true"
										  change="setGridPixels()"
										  visible="{showGridOptions}" includeInLayout="{showGridOptions}"/>
				
				<s:Button id="snapToGrid"
						  width="110"
						  enabled="false"
						  label="Snap To Grid"
						  click="snapToGridDevices()"
						  visible="{showGridOptions}" includeInLayout="{showGridOptions}"/>
				
				<mx:HRule width="100%"
						  visible="{showGridOptions}" includeInLayout="{showGridOptions}"/>
				
				<s:Button width="110"
						  label="Select All"
						  click="selectAll()"
						  visible="{floorplanMode}" includeInLayout="{floorplanMode}"/>
			</mx:VBox>
		</mx:HBox>
		</mx:HBox>
		</mx:HDividedBox>
	</mx:HBox>
</mx:VBox>
